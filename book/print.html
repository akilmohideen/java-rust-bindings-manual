<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java Bindings for Rust: A Comprehensive Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cha01-00.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha01-01.html"><strong aria-hidden="true">1.1.</strong> Purpose of the Manual</a></li><li class="chapter-item expanded "><a href="cha01-02.html"><strong aria-hidden="true">1.2.</strong> Why Java 22?</a></li><li class="chapter-item expanded "><a href="cha01-03.html"><strong aria-hidden="true">1.3.</strong> How Java and Rust Work Together</a></li><li class="chapter-item expanded "><a href="cha01-04.html"><strong aria-hidden="true">1.4.</strong> What This Manual Hopes to Accomplish</a></li></ol></li><li class="chapter-item expanded "><a href="cha02-00.html"><strong aria-hidden="true">2.</strong> Setting Up and Linking Rust and Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha02-01.html"><strong aria-hidden="true">2.1.</strong> How Rust and Java Communicate</a></li><li class="chapter-item expanded "><a href="cha02-02.html"><strong aria-hidden="true">2.2.</strong> Setting Up Rust</a></li><li class="chapter-item expanded "><a href="cha02-03.html"><strong aria-hidden="true">2.3.</strong> Setting Up Java</a></li></ol></li><li class="chapter-item expanded "><a href="cha03-00.html"><strong aria-hidden="true">3.</strong> Mapping Rust Features to Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha03-01.html"><strong aria-hidden="true">3.1.</strong> Accounting for Rust Lifetimes</a></li><li class="chapter-item expanded "><a href="cha03-02.html"><strong aria-hidden="true">3.2.</strong> Handling Ownership and Borrowing</a></li><li class="chapter-item expanded "><a href="cha03-03.html"><strong aria-hidden="true">3.3.</strong> Memory Layouts and Structs</a></li><li class="chapter-item expanded "><a href="cha03-04.html"><strong aria-hidden="true">3.4.</strong> Handling Thread Safety in Rust</a></li><li class="chapter-item expanded "><a href="cha03-05.html"><strong aria-hidden="true">3.5.</strong> Handling Rustâ€™s Enums and Option Types</a></li></ol></li><li class="chapter-item expanded "><a href="cha04-00.html"><strong aria-hidden="true">4.</strong> Handling Common Data Structures</a></li><li class="chapter-item expanded "><a href="cha05-00.html"><strong aria-hidden="true">5.</strong> Edge Cases and Troubleshooting</a></li><li class="chapter-item expanded "><a href="cha06-00.html"><strong aria-hidden="true">6.</strong> Comprehensive Example</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Bindings for Rust: A Comprehensive Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <em><strong>Java Bindings for Rust: A Comprehensive Guide</strong></em>, a guide to using Rust from within Java. This process can be notoriously confusing, and the information on how to do it is dense and scattered across various sources. This guide teaches how to make these bindings in a digestible way. Every section was created to be as short and readable as possible without barring important information. Complex details will be kept in their own sections, and will be linked to when they are applicable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="purpose-of-the-manual"><a class="header" href="#purpose-of-the-manual">Purpose of the Manual</a></h1>
<p>The purpose of this manual is to provide a comprehensive guide for creating Java bindings to Rust libraries using <strong>Java 22</strong> and <strong>Rust 1.81.0</strong>. It will cover the essential steps and concepts required to allow Java applications to call Rust functions, making use of the <strong>Java Foreign Function and Memory API</strong>. By the end of this manual, developers will be able to seamlessly integrate Rustâ€™s high-performance, memory-safe capabilities into their Java applications, enabling cross-language functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-java-22"><a class="header" href="#why-java-22">Why Java 22?</a></h1>
<p>Java 22 introduces the <strong>Foreign Function and Memory API</strong>, a modern alternative to the legacy <strong>Java Native Interface (JNI)</strong>. JNI was traditionally used to interact with C-like functions and data types in external libraries. However, JNI is cumbersome, error-prone, and introduces significant overhead due to repeated native function calls and lack of <strong>Just-In-Time (JIT)</strong> optimizations. Java objects needed to be passed through JNI, requiring additional work on the native side to identify object types and data locations, making the entire process tedious and slow.
With the Foreign Function and Memory API, Java now pushes much of the integration work to the Java side, eliminating the need for custom C headers and providing more visibility for the JIT compiler. This change leads to:</p>
<ul>
<li><strong>Better Performance</strong>: The JIT compiler can now optimize calls to native libraries more effectively.</li>
<li><strong>Simplified Integration</strong>: There are fewer requirements on native function signatures, reducing the overhead of native-to-Java translation.</li>
<li><strong>Enhanced Flexibility</strong>: The API supports working with various languages like Rust while maintaining full control over how memory and function calls are handled.</li>
</ul>
<p>Java 22 is the first version to stabilize this API, making it the ideal choice for this manual. It enables efficient, direct interaction with Rust libraries without the historical drawbacks of JNI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-java-and-rust-work-together"><a class="header" href="#how-java-and-rust-work-together">How Java and Rust Work Together</a></h1>
<p>How Java and Rust Work Together
Rust is a system-level language that provides fine-grained control over memory management, making it a popular choice for performance-critical applications. Java, on the other hand, excels in providing portability and high-level abstractions. By using the Foreign Function and Memory API in Java 22, developers can leverage Rustâ€™s performance and memory safety in Java applications.
Key components of this integration include:</p>
<ul>
<li><strong>Javaâ€™s Foreign Function and Memory API</strong>: This API provides classes such as <code>SymbolLookup</code>, <code>FunctionDescriptor</code>, <code>Linker</code>, <code>MethodHandle</code>, <code>Arena</code>, and <code>MemorySegment</code>, which enable Java to call foreign functions and manage memory effectively.</li>
<li><strong>Rustâ€™s Application Binary Interface (ABI)</strong>: Rust functions exposed to Java must adhere to the <strong>C ABI</strong>, ensuring compatibility between the two languages.</li>
<li><strong>Memory Management</strong>: The manual will explore how to allocate, manage, and release memory safely between Java and Rust, ensuring optimal performance and avoiding memory leaks or undefined behavior.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-this-manual-hopes-to-accomplish"><a class="header" href="#what-this-manual-hopes-to-accomplish">What This Manual Hopes to Accomplish</a></h1>
<p>This manual aims to:</p>
<ol>
<li><strong>Provide a Step-by-Step Guide</strong>: It will walk developers through setting up their environment, configuring Rust and Java projects, and linking the two using the Foreign Function and Memory API.</li>
<li><strong>Demonstrate Practical Examples</strong>: By the end of the manual, developers will have worked through real-world examples, including exposing Rust functions, handling complex data types, managing lifetimes and memory, and handling multi-threading.</li>
<li><strong>Simplify Rust-Java Integration</strong>: The manual will demystify the integration process, helping developers avoid common pitfalls related to ownership, memory management, and data layout discrepancies.</li>
<li><strong>Address Advanced Topics</strong>: In addition to the basics, the manual will explore advanced topics such as thread safety, handling Rustâ€™s ownership and borrowing rules in Java, and how to handle complex data structures and edge cases.</li>
</ol>
<p>By following this guide, developers will gain a deep understanding of how to efficiently and safely call Rust libraries from Java, making full use of both Java 22â€™s Foreign Function and Memory API and Rustâ€™s robust performance and memory safety features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-and-linking-rust-and-java"><a class="header" href="#setting-up-and-linking-rust-and-java">Setting Up and Linking Rust and Java</a></h1>
<p>In this section, we will explain how to set up and link the Rust and Java sides to create Java bindings for Rust libraries. This process involves configuring Rust to export functions in a way Java can access, and using Java's <strong>Foreign Function and Memory API</strong> to dynamically link to the Rust code. We'll also cover how to work with <strong>FunctionDescriptors</strong>, <strong>Arenas</strong>, <strong>MemoryLayouts</strong>, and other key components necessary to ensure safe and efficient communication between Java and Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-rust-and-java-communicate"><a class="header" href="#how-rust-and-java-communicate">How Rust and Java Communicate</a></h1>
<p>Java and Rust communicate through <strong>dynamic linking</strong>, where Rust compiles into a shared library file (e.g., <code>.dll</code> on Windows, <code>.so</code> on Linux, <code>.dylib</code> on macOS). Java loads this library and interacts with its functions using the <strong>Foreign Function and Memory API</strong>, which is part of <strong>Java 22</strong>.
At a high level, the process looks like this:</p>
<ol>
<li><strong>Rust</strong>: You write Rust functions, export them with <code>#[no_mangle]</code> and extern <code>"C"</code>, and compile them into a shared library.</li>
<li><strong>Java</strong>: You use Javaâ€™s <strong>Foreign Function and Memory API</strong> to load the shared library, find the Rust functions, and invoke them.
Now, letâ€™s go step by step through both the Rust and Java setups.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-rust"><a class="header" href="#setting-up-rust">Setting Up Rust</a></h1>
<h2 id="step-1-exporting-rust-functions"><a class="header" href="#step-1-exporting-rust-functions">Step 1: Exporting Rust Functions</a></h2>
<p>To make Rust functions callable from Java, we need to do two things:</p>
<ul>
<li>Use <code>#[no_mangle]</code> to prevent Rust from renaming (mangling) the function name. This ensures Java can find the function by its exact name.</li>
<li>Declare the function with <code>extern "C"</code> to make sure it uses the <strong>C Application Binary Interface (ABI)</strong>, which Java understands.</li>
</ul>
<h3 id="rust-example"><a class="header" href="#rust-example">Rust Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn create_point(x: i32, y: i32) -&gt; *mut Point {
    Box::into_raw(Box::new(Point { x, y }))
}

#[no_mangle]
pub extern "C" fn get_x(point: *mut Point) -&gt; i32 {
    unsafe { (*point).x }
}

#[no_mangle]
pub extern "C" fn free_point(point: *mut Point) {
    unsafe { Box::from_raw(point); } // Frees the allocated memory
}

struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation:</a></h3>
<ul>
<li><code>#[no_mangle]:</code> Prevents Rust from changing the functionâ€™s name during compilation. Without this, Java would not be able to call the function by its original name (create_point).</li>
<li><code>extern "C":</code> This tells Rust to use the <strong>C ABI</strong>, ensuring compatibility with Javaâ€™s native linking mechanism.</li>
<li><code>*mut Point:</code> The function returns a raw pointer (*mut Point), which Java can manage using the Foreign Function and Memory API.</li>
</ul>
<h2 id="step-2-compiling-rust-into-a-shared-library"><a class="header" href="#step-2-compiling-rust-into-a-shared-library">Step 2: Compiling Rust into a Shared Library</a></h2>
<p>To compile the Rust code into a format Java can load, modify the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]
</code></pre>
<p>Then, compile the Rust project into a shared library:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>This command will generate a shared library file (e.g., <code>libmyrustlib.so</code> or <code>myrustlib.dll</code>) in the <code>target/release/</code> directory, which Java can dynamically load.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-java"><a class="header" href="#setting-up-java">Setting Up Java</a></h1>
<p>Once the Rust library is compiled, Java can load the shared library and access the Rust functions using the <em>Foreign Function and Memory API</em>.</p>
<h2 id="step-1-loading-the-rust-shared-library"><a class="header" href="#step-1-loading-the-rust-shared-library">Step 1: Loading the Rust Shared Library</a></h2>
<p>Java uses <strong><code>SymbolLookup</code></strong> to load the shared library and retrieve the addresses of the Rust functions. Javaâ€™s <strong><code>Linker</code></strong> allows us to bind those addresses to callable <code>MethodHandle</code> objects, which represent native functions in Java.
Hereâ€™s how to load the Rust library and link the <code>create_point</code> function:</p>
<h3 id="java-example"><a class="header" href="#java-example">Java Example</a></h3>
<pre><code class="language-java">import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;

public class RustBindings {
    static MethodHandle createPoint;
    static MethodHandle getX;
    static MethodHandle freePoint;

    static {
        var linker = Linker.nativeLinker(); // Initializes the native linker
        var lib = SymbolLookup.libraryLookup("libmyrustlib.so", Arena.global()); // Loads the Rust library

        // Link the Rust functions
        createPoint = linker.downcallHandle(
            lib.find("create_point").orElseThrow(), 
            FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT)
        );
        getX = linker.downcallHandle(
            lib.find("get_x").orElseThrow(), 
            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS)
        );
        freePoint = linker.downcallHandle(
            lib.find("free_point").orElseThrow(), 
            FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)
        );
    }
}
</code></pre>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation:</a></h3>
<ul>
<li><strong><code>libraryLookup</code></strong>: Loads the Rust shared library (<code>libmyrustlib.so</code>). The library must be available in the Java classpath or in the systemâ€™s library path.</li>
<li><strong><code>FunctionDescriptor</code></strong>: Defines the signature of the Rust function in Java terms. For example:
<ul>
<li><strong><code>ValueLayout.ADDRESS</code></strong>: Corresponds to a pointer (Rustâ€™s <code>*mut</code>).</li>
<li><strong><code>ValueLayout.JAVA_INT</code></strong>: Corresponds to Rustâ€™s <code>i32</code>.</li>
</ul>
</li>
<li>MethodHandle: Represents the linked Rust function. This is how Java will call the Rust function.</li>
</ul>
<h2 id="step-2-calling-rust-functions-from-java"><a class="header" href="#step-2-calling-rust-functions-from-java">Step 2: Calling Rust Functions from Java</a></h2>
<p>With the library loaded and the functions linked, we can now call the Rust functions from Java using <code>MethodHandle.invokeExact()</code>. Hereâ€™s how to create a point in Rust, get its <code>x</code> value, and free the memory:</p>
<h3 id="java-example-1"><a class="header" href="#java-example-1">Java Example</a></h3>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws Throwable {
        // Create a point in Rust
        MemorySegment point = (MemorySegment) RustBindings.createPoint.invokeExact(10, 20);

        // Get the x value from the point
        int xValue = (int) RustBindings.getX.invokeExact(point);
        System.out.println("X value: " + xValue);

        // Free the Rust point
        RustBindings.freePoint.invokeExact(point);
    }
}
</code></pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation:</a></h3>
<ul>
<li><strong><code>MemorySegment</code></strong>: This is Javaâ€™s way of handling memory passed to and from Rust. Here, it represents the raw pointer to the Rust Point structure.</li>
<li><strong><code>nvokeExact()</code></strong>: Calls the linked Rust function with the specified arguments. In this case:
<ul>
<li><code>RustBindings.createPoint.invokeExact(10, 20)</code> creates a <code>Point</code> in Rust with <code>x = 10</code> and <code>y = 20</code>.</li>
<li><code>RustBindings.getX.invokeExact(point)</code> retrieves the <code>x</code> value from the Rust point.</li>
<li><code>RustBindings.freePoint.invokeExact(point)</code> frees the memory in Rust.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapping-rust-features-to-java"><a class="header" href="#mapping-rust-features-to-java">Mapping Rust Features to Java</a></h1>
<p>In this section, we will cover how to map key Rust features to their Java equivalents. For each Rust concept, we'll go through:</p>
<ol>
<li>How to Identify the feature in Rust.</li>
<li>What to do in Java to handle it properly.
By the end of this section, you'll be able to look at a Rust function and determine what needs to be written in Java to bind it correctly. This includes handling lifetimes, ownership, memory layouts, thread safety, and more.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accounting-for-rust-lifetimes"><a class="header" href="#accounting-for-rust-lifetimes">Accounting for Rust Lifetimes</a></h1>
<h2 id="identifying-lifetimes-in-rust"><a class="header" href="#identifying-lifetimes-in-rust">Identifying Lifetimes in Rust</a></h2>
<p>In Rust, <strong>lifetimes</strong> are used to manage how long references (<code>&amp;</code>, <code>&amp;mut</code>) are valid. Lifetimes ensure that references to data donâ€™t outlive the data they point to, preventing dangling pointers. Lifetimes are commonly seen in function signatures or struct definitions as <code>&lt;'a&gt;</code> annotations.</p>
<h3 id="example"><a class="header" href="#example">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn borrow&lt;'a&gt;(input: &amp;'a i32) -&gt; &amp;'a i32 {
    input
}
<span class="boring">}</span></code></pre></pre>
<p>In the above example, <code>input</code> has a lifetime <code>'a</code>, and the return type shares the same lifetime. This means the reference returned by the function cannot outlive the reference passed to it.</p>
<h2 id="handling-lifetimes-in-java"><a class="header" href="#handling-lifetimes-in-java">Handling Lifetimes in Java</a></h2>
<p>Java does not have explicit lifetimes, so we need to simulate Rustâ€™s lifetime behavior using <strong>memory management techniques</strong>. Specifically, when dealing with temporary references in Rust, you can manage the memory in Java using <strong>Arenas</strong> from the Foreign Function and Memory API.</p>
<h3 id="what-you-need-to-do"><a class="header" href="#what-you-need-to-do">What You Need to Do:</a></h3>
<ul>
<li><strong>For short-lived references</strong>: Use <strong>Confined Arenas</strong> in Java, ensuring the memory is released once the function is done.</li>
<li><strong>For long-lived references</strong>: Use <strong>Global Arenas</strong> if the reference needs to persist across multiple calls.</li>
</ul>
<h3 id="java-example-handling-lifetimes"><a class="header" href="#java-example-handling-lifetimes">Java Example (Handling Lifetimes):</a></h3>
<pre><code class="language-java">// Create a confined arena for a short-lived Rust reference
var arena = Arena.ofConfined();
MemorySegment borrowedSegment = arena.allocate(8);  // Allocate 8 bytes for a reference

// Call the Rust function, passing in the borrowed reference
RustBindings.borrow.invokeExact(borrowedSegment);

// When the arena is closed, the memory is freed
arena.close();  // Ensures the borrowed reference is no longer accessible
</code></pre>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation:</a></h3>
<ul>
<li><strong>Confined Arena</strong>s are used here to manage temporary references, ensuring that the memory is properly cleaned up after the Rust function is done.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-ownership-and-borrowing"><a class="header" href="#handling-ownership-and-borrowing">Handling Ownership and Borrowing</a></h1>
<h2 id="identifying-ownership-and-borrowing-in-rust"><a class="header" href="#identifying-ownership-and-borrowing-in-rust">Identifying Ownership and Borrowing in Rust</a></h2>
<p>Rust enforces strict ownership rules. When a function in Rust <strong>takes ownership</strong> of a value (e.g., <code>Box</code>, <code>Vec</code>), it means the caller no longer owns that value and cannot use it again unless ownership is returned. Borrowing (<code>&amp;T</code> or <code>&amp;mut</code> T) allows temporary access to a value without transferring ownership.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn take_ownership(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // Takes ownership of v
    v
}

fn borrow(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // Borrows v temporarily
    v[0]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-ownership-in-java"><a class="header" href="#handling-ownership-in-java">Handling Ownership in Java</a></h2>
<p>When Rust functions take ownership of values, Java needs to manage when to free the underlying memory. This typically involves:</p>
<ol>
<li><strong>Taking ownership</strong>: If Java creates the object (e.g., calling <code>Box</code> in Rust), it must free the object explicitly.</li>
<li><strong>Borrowing</strong>: Java must ensure the memory is valid during the borrowed referenceâ€™s lifetime.</li>
</ol>
<h3 id="what-you-need-to-do-1"><a class="header" href="#what-you-need-to-do-1">What You Need to Do:</a></h3>
<ul>
<li><strong>For functions that take ownership</strong>: You need to call the appropriate Rust cleanup function (<code>like</code> drop or <code>free</code>) using <strong>MethodHandle</strong> in Java.</li>
<li><strong>For borrowed references</strong>: Manage memory using <strong>Arenas</strong> to ensure that memory remains valid for the borrowed duration.</li>
</ul>
<h3 id="java-example-handling-ownership"><a class="header" href="#java-example-handling-ownership">Java Example (Handling Ownership):</a></h3>
<pre><code class="language-java">// Create a Rust-owned Box and pass ownership MemorySegment rustBox = (MemorySegment) 
RustBindings.createBox.invokeExact(10); 

// Call Rust function to take ownership of the box 
RustBindings.takeOwnership.invokeExact(rustBox); 

// Manually free the Box when done 
RustBindings.freeBox.invokeExact(rustBox); // Ensures no memory leaks
</code></pre>
<h3 id="explanation-4"><a class="header" href="#explanation-4">Explanation:</a></h3>
<p><strong>MemorySegment</strong> represents the Rust-allocated memory in Java. After transferring ownership to Rust, Java explicitly calls <code>freeBox</code> to release the memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-layouts-and-structs"><a class="header" href="#memory-layouts-and-structs">Memory Layouts and Structs</a></h1>
<h2 id="identifying-structs-and-memory-layouts-in-rust"><a class="header" href="#identifying-structs-and-memory-layouts-in-rust">Identifying Structs and Memory Layouts in Rust</a></h2>
<p>When Rust returns complex data types like <strong>structs</strong> or <strong>arrays</strong>, Java needs to correctly interpret their memory layout. Rustâ€™s struct fields are aligned in memory based on their type sizes, so Java must use <strong>StructLayout</strong> and <strong>ValueLayout</strong> to match the Rust memory layout exactly.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[repr(C)]</code> attribute ensures that the memory layout of <code>Point</code> follows the <code>C ABI</code>, making it compatible with Javaâ€™s Foreign Function and Memory API.</p>
<h2 id="handling-structs-in-java"><a class="header" href="#handling-structs-in-java">Handling Structs in Java</a></h2>
<p>Java uses <strong>StructLayout</strong> to define memory layouts that match Rustâ€™s struct layouts. When dealing with Rust structs, itâ€™s essential to ensure that the memory allocated on the Java side is properly aligned and of the correct size to match the layout of the Rust struct.</p>
<h3 id="what-you-need-to-do-2"><a class="header" href="#what-you-need-to-do-2">What You Need to Do:</a></h3>
<ul>
<li>Use <strong>StructLayout</strong> to define the memory layout that mirrors the fields of the Rust struct.</li>
<li>Allocate a <strong>MemorySegment</strong> that is large enough and properly aligned to hold the structâ€™s data.</li>
</ul>
<h2 id="java-example-handling-structs"><a class="header" href="#java-example-handling-structs">Java Example (Handling Structs):</a></h2>
<pre><code class="language-java">// Define the memory layout of the Rust `Point` struct in Java
StructLayout pointLayout = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName("x"),  // Field `x` (i32 in Rust)
    ValueLayout.JAVA_INT.withName("y")   // Field `y` (i32 in Rust)
);

// Allocate memory for the struct
var arena = Arena.ofConfined();  // Confined Arena for memory management
MemorySegment pointSegment = arena.allocate(pointLayout);

// Set the fields of the Point struct
VarHandle xHandle = pointLayout.varHandle(PathElement.groupElement("x"));
VarHandle yHandle = pointLayout.varHandle(PathElement.groupElement("y"));
xHandle.set(pointSegment, 0, 10);  // Set x to 10
yHandle.set(pointSegment, 0, 20);  // Set y to 20
</code></pre>
<h2 id="explanation-5"><a class="header" href="#explanation-5">Explanation:</a></h2>
<p><strong>StructLayout</strong>: Defines the layout of the Rust <code>Point</code> struct, where each field is aligned according to its type (in this case, both fields are <code>i32</code>, so each is 4 bytes).
<strong>VarHandle</strong>: Used to access and set individual fields (<code>x</code> and <code>y</code>) in the memory segment allocated for the struct.
<strong>MemorySegment</strong>: Represents the allocated memory for the struct, and Java can safely manipulate it according to the structâ€™s layout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-thread-safety-in-rust"><a class="header" href="#handling-thread-safety-in-rust">Handling Thread Safety in Rust</a></h1>
<h2 id="identifying-thread-safety-in-rust"><a class="header" href="#identifying-thread-safety-in-rust">Identifying Thread Safety in Rust</a></h2>
<p>In Rust, <strong>thread safety</strong> is ensured using the Send and Sync traits. If a Rust function operates across multiple threads, the types used in the function must implement <code>Send</code> or <code>Sync</code>. For example, if a Rust function uses a <strong>Mutex</strong> or <strong>Arc</strong> to manage shared data, it is thread-safe.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

pub fn create_shared_data() -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; {
    Arc::new(Mutex::new(42))
}
<span class="boring">}</span></code></pre></pre>
<p>The function returns a thread-safe <code>Arc&lt;Mutex&lt;i32&gt;&gt;</code>, which ensures that multiple threads can safely access and modify the shared data.</p>
<h2 id="ensuring-thread-safety-in-java"><a class="header" href="#ensuring-thread-safety-in-java">Ensuring Thread Safety in Java</a></h2>
<p>When dealing with thread safety across languages, Java must ensure that memory is safely shared between threads. Javaâ€™s Foreign Function and Memory API provides <strong>Shared Arenas</strong>, which allow memory to be safely accessed by multiple threads.</p>
<h3 id="what-you-need-to-do-3"><a class="header" href="#what-you-need-to-do-3">What You Need to Do:</a></h3>
<ul>
<li>Use <strong>Shared Arenas</strong> when you expect shared memory or thread-safe operations in Rust.</li>
<li>Java also provides synchronization mechanisms like <strong>synchronized blocks</strong> to ensure thread safety.</li>
</ul>
<h3 id="java-example-handling-thread-safety"><a class="header" href="#java-example-handling-thread-safety">Java Example (Handling Thread Safety):</a></h3>
<pre><code class="language-java">// Create a shared arena for multi-threaded operations
var sharedArena = Arena.ofShared();
MemorySegment sharedSegment = sharedArena.allocate(8);  // Allocate space for shared memory

// Call Rust function that operates on shared data
RustBindings.createSharedData.invokeExact(sharedSegment);

// Access shared data across threads (ensure proper synchronization in Java)
synchronized (sharedSegment) {
    // Safe access to shared memory here
}
</code></pre>
<h3 id="explanation-6"><a class="header" href="#explanation-6">Explanation:</a></h3>
<ul>
<li><strong>Shared Arena</strong>: Ensures that memory is safely shared across threads in Java when interacting with Rustâ€™s thread-safe types like <code>Arc</code> and <code>Mutex</code>.</li>
<li><strong>Synchronized Block</strong>: Ensures that only one thread accesses the shared memory at a time, mimicking Rustâ€™s ownership rules for shared data.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-rusts-enums-and-option-types"><a class="header" href="#handling-rusts-enums-and-option-types">Handling Rustâ€™s Enums and Option Types</a></h1>
<h2 id="identifying-enums-in-rust"><a class="header" href="#identifying-enums-in-rust">Identifying Enums in Rust</a></h2>
<p>Rust enums can either be <strong>C-like (simple variants)</strong> or contain <strong>data</strong>. When using Rust enums with Java, the structure of the enum must be carefully mapped to Javaâ€™s memory layout and control structures.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>This is a typical enum used for error handling in Rust. The <code>Result</code> enum can hold either an <code>Ok</code> variant (with data) or an <code>Err</code> variant (with error information).</p>
<h2 id="handling-enums-in-java"><a class="header" href="#handling-enums-in-java">Handling Enums in Java</a></h2>
<p>Java doesnâ€™t natively support Rust enums, but you can handle them by:</p>
<ol>
<li>Mapping the enumâ€™s layout to Java using <strong>MemoryLayout</strong>.</li>
<li><strong>Using tagged unions</strong>: Accessing the enumâ€™s <strong>tag</strong> (discriminator) to determine which variant is active.
What You Need to Do:</li>
</ol>
<ul>
<li>Use <strong>MemoryLayout.structLayout()</strong> to match the enum layout.</li>
<li>Use <strong>VarHandle</strong> to check the enumâ€™s tag and access the relevant data based on the active variant.</li>
</ul>
<h3 id="java-example-handling-enums"><a class="header" href="#java-example-handling-enums">Java Example (Handling Enums):</a></h3>
<pre><code class="language-java">// Define the memory layout for the Rust `Result` enum (assumes a tag and data layout)
StructLayout resultLayout = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName("tag"),  // Enum tag (discriminator)
    ValueLayout.JAVA_INT.withName("data")  // Enum data (e.g., Ok or Err)
);

// Allocate memory for the enum
MemorySegment resultSegment = arena.allocate(resultLayout);

// Access the enum tag to determine the variant
VarHandle tagHandle = resultLayout.varHandle(PathElement.groupElement("tag"));
int tag = (int) tagHandle.get(resultSegment);

// Check the enum variant (assumes 0 for Ok, 1 for Err)
if (tag == 0) {
    // Handle Ok variant
} else {
    // Handle Err variant
}
</code></pre>
<h3 id="explanation-7"><a class="header" href="#explanation-7">Explanation:</a></h3>
<p><strong>StructLayout</strong>: Defines the layout of the <code>Result</code> enum, where the tag field identifies the active variant (similar to a union tag in C).
<strong>VarHandle</strong>: Used to read the tag and access the data based on the active enum variant.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-common-data-structures"><a class="header" href="#handling-common-data-structures">Handling Common Data Structures</a></h1>
<p>text</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edge-cases-and-troubleshooting"><a class="header" href="#edge-cases-and-troubleshooting">Edge Cases and Troubleshooting</a></h1>
<p>text</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comprehensive-example"><a class="header" href="#comprehensive-example">Comprehensive Example</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
