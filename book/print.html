<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Java Bindings for Rust: A Comprehensive Guide</a></li><li class="chapter-item expanded "><a href="cha01-00.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha01-01.html"><strong aria-hidden="true">1.1.</strong> Purpose of the Manual</a></li><li class="chapter-item expanded "><a href="cha01-02.html"><strong aria-hidden="true">1.2.</strong> Why Java 22?</a></li><li class="chapter-item expanded "><a href="cha01-03.html"><strong aria-hidden="true">1.3.</strong> How Java and Rust Work Together</a></li><li class="chapter-item expanded "><a href="cha01-04.html"><strong aria-hidden="true">1.4.</strong> What This Manual Hopes to Accomplish</a></li></ol></li><li class="chapter-item expanded "><a href="cha02-00.html"><strong aria-hidden="true">2.</strong> Setting Up and Linking Rust and Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha02-01.html"><strong aria-hidden="true">2.1.</strong> How Rust and Java Communicate</a></li><li class="chapter-item expanded "><a href="cha02-02.html"><strong aria-hidden="true">2.2.</strong> Setting Up Rust</a></li><li class="chapter-item expanded "><a href="cha02-03.html"><strong aria-hidden="true">2.3.</strong> Setting Up Java</a></li></ol></li><li class="chapter-item expanded "><a href="cha03-00.html"><strong aria-hidden="true">3.</strong> Mapping Rust Features to Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha03-02.html"><strong aria-hidden="true">3.1.</strong> Handling Ownership and Borrowing</a></li><li class="chapter-item expanded "><a href="cha03-03.html"><strong aria-hidden="true">3.2.</strong> Memory Layouts and Structs</a></li><li class="chapter-item expanded "><a href="cha03-04.html"><strong aria-hidden="true">3.3.</strong> Handling Thread Safety in Rust</a></li></ol></li><li class="chapter-item expanded "><a href="cha04-00.html"><strong aria-hidden="true">4.</strong> Handling Common Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha04-01.html"><strong aria-hidden="true">4.1.</strong> Handling Rust Structs in Java</a></li><li class="chapter-item expanded "><a href="cha04-02.html"><strong aria-hidden="true">4.2.</strong> Handling Rust Arrays in Java</a></li><li class="chapter-item expanded "><a href="cha04-03.html"><strong aria-hidden="true">4.3.</strong> Handling Rust Vectors (Vec1) in Java</a></li><li class="chapter-item expanded "><a href="cha04-04.html"><strong aria-hidden="true">4.4.</strong> Handling Rust Slices (&[T] and &mut [T]) in Java</a></li></ol></li><li class="chapter-item expanded "><a href="cha05-00.html"><strong aria-hidden="true">5.</strong> Edge Cases and Troubleshooting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha05-01.html"><strong aria-hidden="true">5.1.</strong> Handling Rust Lifetimes in Java</a></li><li class="chapter-item expanded "><a href="cha05-02.html"><strong aria-hidden="true">5.2.</strong> Handling Enums with Data Variants</a></li><li class="chapter-item expanded "><a href="cha05-03.html"><strong aria-hidden="true">5.3.</strong> WrongMethodTypeException in invokeExact()</a></li><li class="chapter-item expanded "><a href="cha05-04.html"><strong aria-hidden="true">5.4.</strong> Segmentation Fault or Undefined Behavior</a></li><li class="chapter-item expanded "><a href="cha05-05.html"><strong aria-hidden="true">5.5.</strong> UnsatisfiedLinkError When Loading Rust Shared Library</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="value_layout.html"><strong aria-hidden="true">6.</strong> Value Layout</a></li><li class="chapter-item expanded "><a href="method_handle.html"><strong aria-hidden="true">7.</strong> Method Handle</a></li><li class="chapter-item expanded "><a href="memory_layout.html"><strong aria-hidden="true">8.</strong> Memory Layout</a></li><li class="chapter-item expanded "><a href="memory_segment.html"><strong aria-hidden="true">9.</strong> Memory Segment</a></li><li class="chapter-item expanded "><a href="variable_handle.html"><strong aria-hidden="true">10.</strong> Variable Handle</a></li><li class="chapter-item expanded "><a href="function_descriptor.html"><strong aria-hidden="true">11.</strong> Function Descriptor</a></li><li class="chapter-item expanded "><a href="struct_layout.html"><strong aria-hidden="true">12.</strong> Struct Layout</a></li><li class="chapter-item expanded "><a href="union_layout.html"><strong aria-hidden="true">13.</strong> Union Layout</a></li><li class="chapter-item expanded "><a href="sequence_layout.html"><strong aria-hidden="true">14.</strong> Sequence Layout</a></li><li class="chapter-item expanded "><a href="arenas.html"><strong aria-hidden="true">15.</strong> Arena</a></li><li class="chapter-item expanded "><a href="so.html"><strong aria-hidden="true">16.</strong> Shared Object and Dynamic Library Files</a></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">17.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="borrowing_and_aliasing.html"><strong aria-hidden="true">18.</strong> Borrowing and Aliasing</a></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">19.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="sym_ex_gen.html"><strong aria-hidden="true">20.</strong> Symbols, Extern, and Generics</a></li><li class="chapter-item expanded "><a href="size_and_alignment.html"><strong aria-hidden="true">21.</strong> Size and Alignment</a></li><li class="chapter-item expanded "><a href="subtyping_and_variance.html"><strong aria-hidden="true">22.</strong> Subtyping and Variance</a></li><li class="chapter-item expanded "><a href="unwinding.html"><strong aria-hidden="true">23.</strong> Unwinding</a></li><li class="chapter-item expanded "><a href="phantom_data.html"><strong aria-hidden="true">24.</strong> Phantom Data</a></li><li class="chapter-item expanded "><a href="send_and_sync.html"><strong aria-hidden="true">25.</strong> Send and Sync</a></li><li class="chapter-item expanded "><a href="data_races.html"><strong aria-hidden="true">26.</strong> Data Races</a></li><li class="chapter-item expanded "><a href="atomics.html"><strong aria-hidden="true">27.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="reordering.html"><strong aria-hidden="true">28.</strong> Compiler and Hardware Reordering</a></li><li class="chapter-item expanded "><a href="data_accesses.html"><strong aria-hidden="true">29.</strong> Data Accesses</a></li><li class="chapter-item expanded "><a href="orderings.html"><strong aria-hidden="true">30.</strong> Orderings</a></li><li class="chapter-item expanded "><a href="uninitialized_memory.html"><strong aria-hidden="true">31.</strong> Uninitialized Memory</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="java-bindings-for-rust-a-comprehensive-guide"><a class="header" href="#java-bindings-for-rust-a-comprehensive-guide">Java Bindings for Rust: A Comprehensive Guide</a></h1>
<p><em>by Akil Mohideen, Natalya McKay, Santiago Martinez Sverko, and Seth Kaul</em>
<em>Sponsored by Ethan McCue</em></p>
<p>This document assumes you have <strong>Rust 1.81.0</strong> and <strong>Java 22</strong> or later. If you have not installed Rust or Java, you can install Rust <a href="https://www.rust-lang.org/tools/install">here</a> and Java <a href="https://www.oracle.com/java/technologies/downloads/">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <em><strong>Java Bindings for Rust: A Comprehensive Guide</strong></em>, a guide to using Rust from within Java. This process can be notoriously confusing, and the information on how to do it is dense and scattered across various sources. This guide teaches how to make these bindings in a digestible way. Every section was created to be as short and readable as possible without barring important information. Complex details will be kept in their own sections, and will be linked to when they are applicable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="purpose-of-the-manual"><a class="header" href="#purpose-of-the-manual">Purpose of the Manual</a></h1>
<p>The purpose of this manual is to provide a comprehensive guide for creating Java bindings to Rust libraries using <strong>Java 22</strong> and <strong>Rust 1.81.0</strong>. It will cover the essential steps and concepts required to allow Java applications to call Rust functions, making use of the <a href="https://openjdk.org/jeps/454">Foreign Function and Memory API</a>. By the end of this manual, developers will be able to seamlessly integrate Rust’s high-performance, memory-safe capabilities into their Java applications, enabling cross-language functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-java-22"><a class="header" href="#why-java-22">Why Java 22?</a></h1>
<p>Java 22 introduces the <a href="https://openjdk.org/jeps/454">Foreign Function and Memory API</a> (FFM API), a modern alternative to the legacy <strong>Java Native Interface (JNI)</strong>. JNI was traditionally used to interact with C-like functions and data types in external libraries. However, JNI is cumbersome, error-prone, and introduces significant overhead due to repeated native function calls and lack of <strong>Just-In-Time (JIT)</strong> optimizations. Java objects needed to be passed through JNI, requiring additional work on the native side to identify object types and data locations, making the entire process tedious and slow.
With the FFM API, Java now pushes much of the integration work to the Java side, eliminating the need for custom C headers and providing more visibility for the JIT compiler.</p>
<p>This change leads to <strong>Better Performance</strong>, as the JIT compiler can now optimize calls to native libraries more effectively. It also leads to <strong>Simplified Integration</strong> because there are fewer requirements on native function signatures. This reduces the overhead of native-to-Java translation. Additionally, the API provides <strong>Enhanced Flexibility</strong>, as it supports working with various languages like Rust while maintaining full control over how memory and function calls are handled.</p>
<p>Java 22 is the first version to stabilize this API, making it the ideal choice for this manual. It enables efficient, direct interaction with Rust libraries without the historical drawbacks of JNI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-java-and-rust-work-together"><a class="header" href="#how-java-and-rust-work-together">How Java and Rust Work Together</a></h1>
<p>How Java and Rust Work Together
Rust is a system-level language that provides fine-grained control over memory management, making it a popular choice for performance-critical applications. Java, on the other hand, excels in providing portability and high-level abstractions. By using the <a href="https://openjdk.org/jeps/454">FFM API</a> in Java 22, developers can leverage Rust’s performance and memory safety in Java applications.</p>
<p>It provides access to classes such as <code>SymbolLookup</code>, <code>FunctionDescriptor</code>, <code>Linker</code>, <code>MethodHandle</code>, <a href="arenas.html"><code>Arena</code></a>, and <code>MemorySegment</code>, which enable Java to call foreign functions and manage memory in more effective ways. On Rust's end, functions exposed to Java must adhere to the <strong>C ABI</strong>, ensuring compatibility between the two languages. The manual will explore how to allocate, manage, and release memory safely between Java and Rust, ensuring optimal performance and avoiding memory leaks or undefined behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-this-manual-hopes-to-accomplish"><a class="header" href="#what-this-manual-hopes-to-accomplish">What This Manual Hopes to Accomplish</a></h1>
<p>By the end, this manual will:</p>
<ol>
<li><strong>Provide a Step-by-Step Guide</strong>: Developers will be walked through setting up bindings between Rust and Java, and configuring these bindings for projects.</li>
<li><strong>Demonstrate Practical Examples</strong>: Examples of properly designed bindings will be provided and explained. These examples will be provided for both easy and complex topics including exposing Rust functions, handling complex data types, managing lifetimes and memory, and handling multi-threading.</li>
<li><strong>Simplify Rust-Java Integration</strong>: The manual will demystify the integration process, helping developers avoid common pitfalls related to ownership, memory management, and data layout discrepancies.</li>
<li><strong>Address Advanced Topics</strong>: In addition to the basics, the manual will explore advanced topics such as thread safety, handling Rust’s ownership and borrowing rules in Java, and how to handle complex data structures and edge cases.</li>
</ol>
<p>By following this guide, developers will gain a deep understanding of how to efficiently and safely call Rust libraries from Java, making full use of both Java 22’s <a href="https://openjdk.org/jeps/454">FFM API</a> and Rust’s robust performance and memory safety features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-and-linking-rust-and-java"><a class="header" href="#setting-up-and-linking-rust-and-java">Setting Up and Linking Rust and Java</a></h1>
<p>In this section, we will explain how to set up and link both Rust and Java code, in order to create Java bindings for Rust libraries. This process involves exporting Rust functions in a way Java can access, and using Java's <a href="https://openjdk.org/jeps/454">FFM API</a> to dynamically link to Rust code. We will also cover how to work with <a href="function_descriptor.html"><code>FunctionDescriptor</code></a>, <a href="arenas.html"><code>Arena</code></a>, <a href="memory_layout.html"><code>MemoryLayout</code></a>, and other key components necessary to ensure safe and efficient communication between Java and Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-rust-and-java-communicate"><a class="header" href="#how-rust-and-java-communicate">How Rust and Java Communicate</a></h1>
<p>Java and Rust communicate through <strong>dynamic linking</strong>, where Rust compiles into a <a href="so.html">shared library</a> file (e.g., <code>.dll</code> on Windows, <code>.so</code> on Linux, <code>.dylib</code> on macOS). Java loads this library and can interact with its functions.
At a high level, the process looks like this:</p>
<ul>
<li><strong>Rust</strong>: Write Rust functions, export them with <code>#[no_mangle]</code> and <code>extern "C"</code>, and compile them into a shared library.</li>
<li><strong>Java</strong>: Use the Java <a href="https://openjdk.org/jeps/454">FFM API</a> to load the shared library, find the Rust functions, and invoke them.</li>
</ul>
<p>The next sections will go step by step through both the Rust and Java setups.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-rust"><a class="header" href="#setting-up-rust">Setting Up Rust</a></h1>
<h2 id="step-1-exporting-rust-functions"><a class="header" href="#step-1-exporting-rust-functions">Step 1: Exporting Rust Functions</a></h2>
<p>To make Rust functions callable from Java, we need to do two things:</p>
<ul>
<li>Use <a href="sym_ex_gen.html"><code>#[no_mangle]</code></a> to prevent Rust from renaming (mangling) the function name internally. This ensures Java can find the function by its exact name.</li>
<li>Declare the function with <a href="sym_ex_gen.html"><code>extern "C"</code></a> to make sure it uses the <strong>C Application Binary Interface (ABI)</strong>, which Java understands.</li>
</ul>
<h3 id="rust-example"><a class="header" href="#rust-example">Rust Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn create_point(x: i32, y: i32) -&gt; *mut Point {
    Box::into_raw(Box::new(Point { x, y }))
}

#[no_mangle]
pub extern "C" fn get_x(point: *mut Point) -&gt; i32 {
    unsafe { (*point).x }
}

#[no_mangle]
pub extern "C" fn free_point(point: *mut Point) {
    unsafe { Box::from_raw(point); } // Frees the allocated memory
}

struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation:</a></h3>
<ul>
<li><code>*mut Point:</code> The function returns a raw pointer (<code>*mut Point</code>), which Java can manage using the <a href="https://openjdk.org/jeps/454">FFM API</a>.</li>
</ul>
<h2 id="step-2-compiling-rust-into-a-shared-library"><a class="header" href="#step-2-compiling-rust-into-a-shared-library">Step 2: Compiling Rust into a Shared Library</a></h2>
<p>To compile the Rust code into a format Java can load, modify the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]
</code></pre>
<p>Then, compile the Rust project into a <a href="so.html">shared library</a>:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>This command will generate a shared library file (e.g., <code>libmyrustlib.so</code> or <code>myrustlib.dll</code>) in the <code>target/release/</code> directory, which Java can dynamically load.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-java"><a class="header" href="#setting-up-java">Setting Up Java</a></h1>
<p>Once the Rust library is compiled, Java can load the <a href="so.html">shared library</a> and access the Rust functions.</p>
<h2 id="step-1-loading-the-rust-shared-library"><a class="header" href="#step-1-loading-the-rust-shared-library">Step 1: Loading the Rust Shared Library</a></h2>
<p>Java uses <strong><code>SymbolLookup</code></strong> to load the shared library and retrieve the addresses of the Rust functions. Java’s <strong><code>Linker</code></strong> allows us to bind those addresses to callable <a href="method_handle.html"><code>MethodHandle</code></a> objects, which represent native functions in Java.
Here’s how to load the Rust library and link the <code>create_point</code> function:</p>
<h3 id="java-example"><a class="header" href="#java-example">Java Example</a></h3>
<pre><code class="language-java">import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;

public class RustBindings {
    static MethodHandle createPoint;
    static MethodHandle getX;
    static MethodHandle freePoint;

    static {
        var linker = Linker.nativeLinker(); // Initializes the native linker
        var lib = SymbolLookup.libraryLookup("libmyrustlib.so", Arena.global()); // Loads the Rust library

        // Link the Rust functions
        createPoint = linker.downcallHandle(
            lib.find("create_point").orElseThrow(), 
            FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT)
        );
        getX = linker.downcallHandle(
            lib.find("get_x").orElseThrow(), 
            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS)
        );
        freePoint = linker.downcallHandle(
            lib.find("free_point").orElseThrow(), 
            FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)
        );
    }
}
</code></pre>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation:</a></h3>
<ul>
<li><strong><code>libraryLookup</code></strong>: Loads the Rust shared library (<code>libmyrustlib.so</code>). The library must be available in the Java classpath or in the system’s library path.</li>
<li><strong><a href="function_descriptor.html"><code>FunctionDescriptor</code></a></strong>: Defines the signature of the Rust function in Java terms. For example:
<ul>
<li><strong><a href="value_layout.html"><code>ValueLayout</code></a><code>.ADDRESS</code></strong>: Corresponds to a pointer (Rust’s <code>*mut</code>).</li>
<li><strong><code>ValueLayout.JAVA_INT</code></strong>: Corresponds to Rust’s <code>i32</code>.</li>
</ul>
</li>
<li>MethodHandle: Represents the linked Rust function. This is how Java will call the Rust function.</li>
</ul>
<h2 id="step-2-calling-rust-functions-from-java"><a class="header" href="#step-2-calling-rust-functions-from-java">Step 2: Calling Rust Functions from Java</a></h2>
<p>With the library loaded and the functions linked, we can now call the Rust functions from Java using <code>MethodHandle.invokeExact()</code>. Here’s how to create a point in Rust, get its <code>x</code> value, and free the memory:</p>
<h3 id="java-example-1"><a class="header" href="#java-example-1">Java Example</a></h3>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws Throwable {
        // Create a point in Rust
        MemorySegment point = (MemorySegment) RustBindings.createPoint.invokeExact(10, 20);

        // Get the x value from the point
        int xValue = (int) RustBindings.getX.invokeExact(point);
        System.out.println("X value: " + xValue);

        // Free the Rust point
        RustBindings.freePoint.invokeExact(point);
    }
}
</code></pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation:</a></h3>
<ul>
<li><strong><a href="memory_segment.html"><code>MemorySegment</code></a></strong>: This is Java’s way of handling memory passed to and from Rust. Here, it represents the raw pointer to the Rust Point structure.</li>
<li><strong><code>invokeExact()</code></strong>: Calls the linked Rust function with the specified arguments. In this case:
<ul>
<li><code>RustBindings.createPoint.invokeExact(10, 20)</code> creates a <code>Point</code> in Rust with <code>x = 10</code> and <code>y = 20</code>.</li>
<li><code>RustBindings.getX.invokeExact(point)</code> retrieves the <code>x</code> value from the Rust point.</li>
<li><code>RustBindings.freePoint.invokeExact(point)</code> frees the memory in Rust.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapping-rust-features-to-java"><a class="header" href="#mapping-rust-features-to-java">Mapping Rust Features to Java</a></h1>
<p>This section will cover how to properly account for features that are important to Rust. For each Rust concept, the process to Identify a feature and handle it properly in Java will be shown.</p>
<p>By the end of this section, the steps to analyze a Rust function, and determine what needs to be written in Java to bind it correctly, will be clear. This includes handling <a href="lifetimes.html">lifetimes</a>, <a href="ownership.html">ownership</a>, <a href="memory_layout.html">memory layouts</a>, thread safety, and more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-ownership-and-borrowing"><a class="header" href="#handling-ownership-and-borrowing">Handling Ownership and Borrowing</a></h1>
<h2 id="identifying-ownership-and-borrowing-in-rust"><a class="header" href="#identifying-ownership-and-borrowing-in-rust">Identifying Ownership and Borrowing in Rust</a></h2>
<p>Rust enforces strict <a href="ownership.html">ownership</a> rules. When a function in Rust takes ownership of a value (e.g., <code>Box</code>, <code>Vec</code>), it means the caller no longer owns that value and cannot use it again unless ownership is returned. <a href="borrowing_and_aliasing.html">Borrowing</a> (<code>&amp;T</code> or <code>&amp;mut T</code>) allows temporary access to a value without transferring ownership.</p>
<h3 id="example"><a class="header" href="#example">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn take_ownership(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // Takes ownership of v
    v
}

fn borrow(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // Borrows v temporarily
    v[0]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-ownership-in-java"><a class="header" href="#handling-ownership-in-java">Handling Ownership in Java</a></h2>
<p>When Rust functions take ownership of values, Java needs to manage when to free the underlying memory. If Java creates the object (e.g., calling <code>Box</code> in Rust), it must free the object explicitly. Java must also ensure the memory is valid during the borrowed reference’s lifetime.</p>
<h3 id="what-you-need-to-do"><a class="header" href="#what-you-need-to-do">What You Need to Do:</a></h3>
<ul>
<li><strong>For functions that take ownership</strong>: You need to call the appropriate Rust cleanup function (<code>like</code> drop or <code>free</code>) using <strong><a href="method_handle.html"><code>MethodHandle</code></a></strong> in Java.</li>
<li><strong>For borrowed references</strong>: Manage memory using <strong><a href="arenas.html"><code>Arena</code></a></strong> to ensure that memory remains valid for the borrowed duration.</li>
</ul>
<h3 id="java-example-handling-ownership"><a class="header" href="#java-example-handling-ownership">Java Example (Handling Ownership):</a></h3>
<pre><code class="language-java">// Create a Rust-owned Box and pass ownership MemorySegment rustBox = (MemorySegment) 
RustBindings.createBox.invokeExact(10); 

// Call Rust function to take ownership of the box 
RustBindings.takeOwnership.invokeExact(rustBox); 

// Manually free the Box when done 
RustBindings.freeBox.invokeExact(rustBox); // Ensures no memory leaks
</code></pre>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation:</a></h3>
<p><a href="memory_segment.html">MemorySegment</a> represents the Rust-allocated memory in Java. After transferring ownership to Rust, Java explicitly calls <code>freeBox</code> to release the memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-layouts-and-structs"><a class="header" href="#memory-layouts-and-structs">Memory Layouts and Structs</a></h1>
<h2 id="identifying-structs-and-memory-layouts-in-rust"><a class="header" href="#identifying-structs-and-memory-layouts-in-rust">Identifying Structs and Memory Layouts in Rust</a></h2>
<p>When Rust returns complex data types like <strong>structs</strong> or <strong>arrays</strong>, Java needs to correctly interpret their <a href="memory_layout.html">memory layout</a>. Rust’s struct fields are aligned in memory based on their type sizes, so Java must use <strong>StructLayout</strong> and <a href="value_layout.html">ValueLayout</a> to match the Rust memory layout exactly.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[repr(C)]</code> attribute ensures that the memory layout of <code>Point</code> follows the <code>C ABI</code>, making it compatible with Java’s <a href="https://openjdk.org/jeps/454">FFM API</a>.</p>
<h2 id="handling-structs-in-java"><a class="header" href="#handling-structs-in-java">Handling Structs in Java</a></h2>
<p>Java uses <strong>StructLayout</strong> to define memory layouts that match Rust’s struct layouts. When dealing with Rust structs, it’s essential to ensure that the memory allocated on the Java side is properly aligned and of the correct size to match the layout of the Rust struct.</p>
<h3 id="what-you-need-to-do-1"><a class="header" href="#what-you-need-to-do-1">What You Need to Do:</a></h3>
<ul>
<li>Use <strong>StructLayout</strong> to define the memory layout that mirrors the fields of the Rust struct.</li>
<li>Allocate a[<strong>MemorySegment</strong> that is large enough and properly aligned to hold the struct’s data.</li>
</ul>
<h2 id="java-example-handling-structs"><a class="header" href="#java-example-handling-structs">Java Example (Handling Structs):</a></h2>
<pre><code class="language-java">// Define the memory layout of the Rust `Point` struct in Java
StructLayout pointLayout = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName("x"),  // Field `x` (i32 in Rust)
    ValueLayout.JAVA_INT.withName("y")   // Field `y` (i32 in Rust)
);

// Allocate memory for the struct
var arena = Arena.ofConfined();  // Confined Arena for memory management
MemorySegment pointSegment = arena.allocate(pointLayout);

// Set the fields of the Point struct
VarHandle xHandle = pointLayout.varHandle(PathElement.groupElement("x"));
VarHandle yHandle = pointLayout.varHandle(PathElement.groupElement("y"));
xHandle.set(pointSegment, 0, 10);  // Set x to 10
yHandle.set(pointSegment, 0, 20);  // Set y to 20
</code></pre>
<h2 id="explanation-4"><a class="header" href="#explanation-4">Explanation:</a></h2>
<ul>
<li><a href="struct_layout.html"><strong>StructLayout</strong></a>: Defines the layout of the Rust <code>Point</code> struct, where each field is aligned according to its type (in this case, both fields are <code>i32</code>, so each is 4 bytes).</li>
<li><a href="variable_handle.html"><strong>VarHandle</strong></a>: Used to access and set individual fields (<code>x</code> and <code>y</code>) in the memory segment allocated for the struct.</li>
<li><a href="memory_segment.html"><strong>MemorySegment</strong></a>: Represents the allocated memory for the struct, and Java can safely manipulate it according to the struct’s layout.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-thread-safety-in-rust"><a class="header" href="#handling-thread-safety-in-rust">Handling Thread Safety in Rust</a></h1>
<h2 id="identifying-thread-safety-in-rust"><a class="header" href="#identifying-thread-safety-in-rust">Identifying Thread Safety in Rust</a></h2>
<p>In Rust, <strong>thread safety</strong> is ensured using the <a href="send_and_sync.html">Send and Sync</a> traits. If a Rust function operates across multiple threads, the types used in the function must implement <code>Send</code> or <code>Sync</code>. For example, if a Rust function uses a <strong>Mutex</strong> or <strong>Arc</strong> to manage shared data, it is thread-safe.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

pub fn create_shared_data() -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; {
    Arc::new(Mutex::new(42))
}
<span class="boring">}</span></code></pre></pre>
<p>The function returns a thread-safe <code>Arc&lt;Mutex&lt;i32&gt;&gt;</code>, which ensures that multiple threads can safely access and modify the shared data.</p>
<h2 id="ensuring-thread-safety-in-java"><a class="header" href="#ensuring-thread-safety-in-java">Ensuring Thread Safety in Java</a></h2>
<p>When dealing with thread safety across languages, Java must ensure that memory is safely shared between threads. Java’s <a href="https://openjdk.org/jeps/454">FFM API</a> provides <a href="arenas.html"><strong>Shared Arenas</strong></a>, which allow memory to be safely accessed by multiple threads.</p>
<h3 id="what-to-do"><a class="header" href="#what-to-do">What to Do:</a></h3>
<ul>
<li>Use <strong>Shared Arenas</strong> when shared memory or thread-safe operations are expected in Rust.</li>
<li>Java also provides synchronization mechanisms like <strong>synchronized blocks</strong> to ensure thread safety.</li>
</ul>
<h3 id="java-example-handling-thread-safety"><a class="header" href="#java-example-handling-thread-safety">Java Example (Handling Thread Safety):</a></h3>
<pre><code class="language-java">// Create a shared arena for multi-threaded operations
var sharedArena = Arena.ofShared();
MemorySegment sharedSegment = sharedArena.allocate(8);  // Allocate space for shared memory

// Call Rust function that operates on shared data
RustBindings.createSharedData.invokeExact(sharedSegment);

// Access shared data across threads (ensure proper synchronization in Java)
synchronized (sharedSegment) {
    // Safe access to shared memory here
}
</code></pre>
<h3 id="explanation-5"><a class="header" href="#explanation-5">Explanation:</a></h3>
<ul>
<li><strong>Shared Arena</strong>: Ensures that memory is safely shared across threads in Java when interacting with Rust’s thread-safe types like <code>Arc</code> and <code>Mutex</code>.</li>
<li><strong>Synchronized Block</strong>: Ensures that only one thread accesses the shared memory at a time, mimicking Rust’s ownership rules for shared data.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-common-data-structures"><a class="header" href="#handling-common-data-structures">Handling Common Data Structures</a></h1>
<p>This section will walk through how to handle common Rust data structures (like structs, arrays, and enums) in Java, explaining why each element is needed, how it functions, and what to watch out for. We’ll go through practical examples, showing how to declare, access, and clean up these data structures from Java.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-rust-structs-in-java"><a class="header" href="#handling-rust-structs-in-java">Handling Rust Structs in Java</a></h1>
<h2 id="rust-side"><a class="header" href="#rust-side">Rust Side</a></h2>
<p>In Rust, a struct is a user-defined type that groups related values. Structs use specific memory layouts, which must match on the Java side. The layout of structs is especially crucial for cross-language bindings because memory misalignment can lead to undefined behavior.</p>
<h3 id="example-rust-struct"><a class="header" href="#example-rust-struct">Example Rust Struct:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]  // Ensures compatibility with C-style memory layout
struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>Explanation: The <code>#[repr(C)]</code> attribute ensures that the struct is laid out in memory according to the C ABI, which is compatible with Java's FFM API.</p>
<h2 id="java-side"><a class="header" href="#java-side">Java Side</a></h2>
<p>To use this struct in Java, we need to:</p>
<ul>
<li>Define a <code>StructLayout</code> that matches the Rust struct layout.</li>
<li>Use <code>VarHandles</code> to access each struct field.</li>
</ul>
<h3 id="example-java-code"><a class="header" href="#example-java-code">Example Java Code:</a></h3>
<pre><code class="language-java">StructLayout pointLayout = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName("x"),  // Maps to Rust's i32 `x`
    ValueLayout.JAVA_INT.withName("y")   // Maps to Rust's i32 `y`
);

VarHandle xHandle = pointLayout.varHandle(PathElement.groupElement("x"));
VarHandle yHandle = pointLayout.varHandle(PathElement.groupElement("y"));
</code></pre>
<h3 id="explanation-6"><a class="header" href="#explanation-6">Explanation:</a></h3>
<ul>
<li><code>ValueLayout.JAVA_INT</code>: This matches Rust’s i32 type.</li>
<li><code>withName("x")</code> and <code>withName("y")</code>: Naming each field lets us retrieve a VarHandle to read and write to specific fields of the MemorySegment that represents the Rust struct.</li>
</ul>
<h2 id="allocating-and-using-the-struct"><a class="header" href="#allocating-and-using-the-struct">Allocating and Using the Struct</a></h2>
<p><strong>Allocate Memory</strong>: Use an arena to manage the memory allocation.</p>
<p><strong>Access Fields</strong>: Access x and y using VarHandles.</p>
<pre><code class="language-java">var arena = Arena.ofConfined();
MemorySegment pointSegment = arena.allocate(pointLayout);

xHandle.set(pointSegment, 0, 10);  // Set x = 10
yHandle.set(pointSegment, 0, 20);  // Set y = 20

int x = (int) xHandle.get(pointSegment);  // Get x value
int y = (int) yHandle.get(pointSegment);  // Get y value
</code></pre>
<h3 id="explanation-7"><a class="header" href="#explanation-7">Explanation:</a></h3>
<p><strong>Arena Allocation</strong>: Using an arena (e.g., <code>Arena.ofConfined()</code>) ensures the struct’s memory is safely managed.</p>
<p><strong>Set and Get Values</strong>: <code>VarHandle</code> operations allow us to interact with Rust struct fields directly, facilitating cross-language data manipulation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-rust-arrays-in-java"><a class="header" href="#handling-rust-arrays-in-java">Handling Rust Arrays in Java</a></h1>
<h2 id="rust-side-1"><a class="header" href="#rust-side-1">Rust Side</a></h2>
<p>Arrays in Rust are fixed-size collections, and their size and layout must be precisely known for Java to interact with them effectively.</p>
<h3 id="example-rust-array"><a class="header" href="#example-rust-array">Example Rust Array:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn create_array() -&gt; *mut [i32; 5] {
    Box::into_raw(Box::new([1, 2, 3, 4, 5]))
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Explanation</strong>: <code>Box::into_raw</code> creates a raw pointer, enabling Java to handle the array. Here, <code>#[no_mangle]</code> ensures the Rust function name remains unmangled, making it accessible from Java.</p>
<h2 id="java-side-1"><a class="header" href="#java-side-1">Java Side</a></h2>
<p>To handle arrays from Rust in Java:</p>
<ul>
<li>Define a <code>SequenceLayout</code> for the array.</li>
<li>Access elements via <code>VarHandle</code>.</li>
</ul>
<pre><code class="language-java">SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT);
VarHandle elementHandle = arrayLayout.elementVarHandle(ValueLayout.JAVA_INT);
</code></pre>
<p><strong>Explanation</strong>:</p>
<p><strong>SequenceLayout</strong>: This layout describes a fixed-size array (5 elements of <code>i32</code>).</p>
<p><strong>VarHandle</strong>: Provides access to each element in the array.</p>
<h2 id="allocating-and-accessing-elements"><a class="header" href="#allocating-and-accessing-elements">Allocating and Accessing Elements</a></h2>
<pre><code class="language-java">var arena = Arena.ofConfined();
MemorySegment arraySegment = arena.allocate(arrayLayout);

for (int i = 0; i &lt; 5; i++) {
    int value = (int) elementHandle.get(arraySegment, (long) i);
    System.out.println("Array element " + i + ": " + value);
}
</code></pre>
<p><strong>Explanation</strong>:</p>
<p><strong>Memory Allocation</strong>: The array memory is managed within an arena, ensuring safety and easy cleanup.</p>
<p><strong>Element Access</strong>: Each element is accessed via <code>elementHandle</code>, following Rust’s array layout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-rust-vectors-vect1-in-java"><a class="header" href="#handling-rust-vectors-vect1-in-java">Handling Rust Vectors (<code>Vec&lt;T&gt;1</code>) in Java</a></h1>
<h2 id="rust-side-2"><a class="header" href="#rust-side-2">Rust Side</a></h2>
<p>In Rust, a <code>Vec&lt;T&gt;</code> is a dynamically-sized array that includes metadata such as capacity and length. Working with vectors across FFI boundaries requires us to manage these fields carefully on both sides.</p>
<h3 id="example-rust-vector"><a class="header" href="#example-rust-vector">Example Rust Vector:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern "C" fn create_vector() -&gt; *mut Vec&lt;i32&gt; {
    Box::into_raw(Box::new(vec![10, 20, 30]))
}

#[no_mangle]
extern "C" fn vector_push(vec: *mut Vec&lt;i32&gt;, value: i32) {
    unsafe {
        if let Some(vec) = vec.as_mut() {
            vec.push(value);
        }
    }
}

#[no_mangle]
extern "C" fn vector_get(vec: *const Vec&lt;i32&gt;, index: usize) -&gt; i32 {
    unsafe {
        if let Some(vec) = vec.as_ref() {
            vec[index]
        } else {
            0 // Or some error handling
        }
    }
}

#[no_mangle]
extern "C" fn vector_len(vec: *const Vec&lt;i32&gt;) -&gt; usize {
    unsafe {
        if let Some(vec) = vec.as_ref() {
            vec.len()
        } else {
            0
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Explanation</strong>:</p>
<p><code>create_vector</code>: Initializes a <code>Vec&lt;i32&gt;</code> and returns a raw pointer to allow Java to manage the vector.</p>
<p><code>vector_push</code>: Provides functionality for adding elements to the vector, with error handling in case of null pointers.</p>
<p><code>vector_get</code> and <code>vector_len</code>: Fetch elements from the vector and get its length, making direct access possible from Java.</p>
<h2 id="java-side-2"><a class="header" href="#java-side-2">Java Side</a></h2>
<p>To handle <code>Vec&lt;T&gt;</code> in Java:</p>
<ol>
<li>Define a <code>StructLayout</code> that represents the memory layout for a Rust vector (data pointer, length, and capacity).</li>
<li>Use <code>MethodHandles</code> to call Rust functions to manipulate the vector.</li>
</ol>
<h3 id="example-java-code-1"><a class="header" href="#example-java-code-1">Example Java Code:</a></h3>
<pre><code class="language-java">// Define the layout for Vec&lt;i32&gt;
StructLayout vecLayout = MemoryLayout.structLayout(
    ValueLayout.ADDRESS.withName("ptr"),  // Data pointer
    ValueLayout.JAVA_LONG.withName("cap"), // Capacity
    ValueLayout.JAVA_LONG.withName("len")  // Length
);

// MethodHandles to call Rust functions
MethodHandle vectorPush = linker.downcallHandle(
    symbolLookup.lookup("vector_push").get(),
    FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, ValueLayout.JAVA_INT)
);

MethodHandle vectorGet = linker.downcallHandle(
    symbolLookup.lookup("vector_get").get(),
    FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.JAVA_LONG)
);

MethodHandle vectorLen = linker.downcallHandle(
    symbolLookup.lookup("vector_len").get(),
    FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)
);
</code></pre>
<p><strong>Explanation</strong>:</p>
<p><code>vecLayout</code>: Defines the structure of the <code>Vec&lt;T&gt;</code> memory, including data pointer, length, and capacity.</p>
<p><code>MethodHandles</code> (<code>vectorPush</code>, <code>vectorGet</code>, <code>vectorLen</code>): Enable Java to interact with the vector’s core functions.</p>
<h2 id="allocating-and-using-the-vector"><a class="header" href="#allocating-and-using-the-vector">Allocating and Using the Vector</a></h2>
<pre><code class="language-java">var arena = Arena.ofConfined();
MemorySegment vecSegment = arena.allocate(vecLayout);

vectorPush.invokeExact(vecSegment, 42);  // Push 42 to vector
long len = (long) vectorLen.invokeExact(vecSegment); // Get vector length
int value = (int) vectorGet.invokeExact(vecSegment, 0L); // Get first element
</code></pre>
<p><strong>Explanation</strong>:</p>
<p><strong>Arena Allocation</strong>: Using an <code>Arena</code> for safe memory management.
<strong>Push, Length, and Get</strong>: <code>MethodHandle</code> invocations facilitate direct manipulation of the Rust vector from Java.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-rust-slices-t-and-mut-t-in-java"><a class="header" href="#handling-rust-slices-t-and-mut-t-in-java">Handling Rust Slices (<code>&amp;[T]</code> and <code>&amp;mut [T]</code>) in Java</a></h1>
<h2 id="rust-side-3"><a class="header" href="#rust-side-3">Rust Side</a></h2>
<p>In Rust, slices (<code>&amp;[T]</code> and <code>&amp;mut [T]</code>) represent a reference to a contiguous sequence of elements, without ownership. For FFI, we pass both the pointer to the data and the length of the slice.</p>
<h3 id="example-rust-slice"><a class="header" href="#example-rust-slice">Example Rust Slice:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern "C" fn sum_slice(slice: *const i32, len: usize) -&gt; i32 {
    let slice = unsafe { std::slice::from_raw_parts(slice, len) };
    slice.iter().sum()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Explanation</strong>:
<code>sum_slice</code>: Accepts a pointer and a length, allowing Rust to treat them as a slice. This approach enables safe manipulation and reading of slice data in Rust while preserving FFI compatibility.</p>
<h2 id="java-side-3"><a class="header" href="#java-side-3">Java Side</a></h2>
<p>To interact with Rust slices from Java:</p>
<ol>
<li>Define a <code>SequenceLayout</code> that reflects the slice structure.</li>
<li>Use a MethodHandle to invoke Rust’s functions on the slice.</li>
</ol>
<p><strong>Example Java Code</strong>:</p>
<pre><code class="language-java">// Define the layout for an array of 5 integers
SequenceLayout sliceLayout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT);

// MethodHandle for sum_slice function
MethodHandle sumSlice = linker.downcallHandle(
    symbolLookup.lookup("sum_slice").get(),
    FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.JAVA_LONG)
);
</code></pre>
<p><strong>Explanation</strong>:</p>
<ul>
<li><code>sliceLayout</code>: Defines the memory layout for a fixed-size slice.</li>
<li>MethodHandle (<code>sumSlice</code>): Links to Rust’s <code>sum_slice</code> function, allowing Java to call it with a memory segment and length.</li>
</ul>
<h2 id="allocating-and-accessing-slice-elements"><a class="header" href="#allocating-and-accessing-slice-elements">Allocating and Accessing Slice Elements</a></h2>
<pre><code class="language-java">var arena = Arena.ofConfined();
MemorySegment sliceSegment = arena.allocate(sliceLayout);

VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();
intHandle.set(sliceSegment, 0, 10);
intHandle.set(sliceSegment, 1, 20);

int result = (int) sumSlice.invokeExact(sliceSegment, 5L);  // Sum the slice
System.out.println("Sum of slice elements: " + result);
</code></pre>
<p><strong>Explanation</strong>:
<strong>Arena Allocation</strong>: Allocates the slice’s memory in an arena for safe usage.</p>
<p><strong>Setting and Summing Elements</strong>: Uses VarHandles for direct element access and sumSlice for calculating the sum, bridging Rust’s slice handling with Java effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edge-cases-and-troubleshooting"><a class="header" href="#edge-cases-and-troubleshooting">Edge Cases and Troubleshooting</a></h1>
<p>This section is designed to provide solutions for challenging edge cases and common errors Java developers may encounter when working with Rust bindings. Each subsection includes practical examples in Rust and Java, with solutions and explanations on handling complex scenarios such as memory alignment issues, lifetimes, and data races.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-rust-lifetimes-in-java"><a class="header" href="#handling-rust-lifetimes-in-java">Handling Rust Lifetimes in Java</a></h1>
<p>Rust’s <strong>lifetime annotations</strong> ensure that references do not outlive the data they point to. Since Java lacks a direct equivalent, memory management must be handled with precision to avoid accessing invalidated memory.</p>
<h2 id="example-short-lived-borrowed-reference"><a class="header" href="#example-short-lived-borrowed-reference">Example: Short-Lived Borrowed Reference</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn get_reference&lt;'a&gt;(value: &amp;'a i32) -&gt; &amp;'a i32 {
    value
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>get_reference</code> returns a reference to an integer. In Rust, the lifetime <code>'a</code> ensures that the reference <code>value</code> will be valid while it’s borrowed. This reference cannot outlive its source.</p>
<h2 id="java-side-solution"><a class="header" href="#java-side-solution">Java Side Solution:</a></h2>
<p>To prevent accessing invalid memory, Java can use confined arenas for short-lived data.</p>
<pre><code class="language-java">var arena = Arena.ofConfined();
MemorySegment segment = arena.allocate(ValueLayout.JAVA_INT);  // Allocate memory for the reference
MethodHandle getReference = RustBindings.getReferenceHandle();

// Pass and retrieve the reference within the arena's lifetime
int value = 42;
segment.set(ValueLayout.JAVA_INT, 0, value);
MemorySegment borrowed = (MemorySegment) getReference.invokeExact(segment);
arena.close();  // Ensures memory is freed
</code></pre>
<h3 id="explanation-and-solution"><a class="header" href="#explanation-and-solution">Explanation and Solution:</a></h3>
<p><strong>Confined Arena</strong>: The confined arena restricts access to a single thread, ensuring safe memory management. The arena is closed immediately after the operation, so Java cannot access the memory after it’s freed.</p>
<p><strong>Memory Safety</strong>: By confining the memory within the arena, Java developers can ensure they only use memory while it’s valid, preventing accidental reuse.</p>
<h2 id="why-its-tricky"><a class="header" href="#why-its-tricky">Why It’s Tricky:</a></h2>
<p>Rust’s lifetimes prevent data from being used after it’s freed, while Java’s garbage collection doesn’t directly support this. Confined arenas provide a reliable method to approximate Rust’s memory safety, but they require Java developers to actively manage their memory, which can be challenging.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-enums-with-data-variants"><a class="header" href="#handling-enums-with-data-variants">Handling Enums with Data Variants</a></h1>
<p>Rust enums are often more complex than Java enums since they can carry data. Java needs to map Rust enums to a compatible structure, identifying active variants to avoid misinterpreting memory.</p>
<h2 id="example-enum-with-multiple-variants"><a class="header" href="#example-enum-with-multiple-variants">Example: Enum with Multiple Variants</a></h2>
<p><strong>Rust Side</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub enum Status {
    Ok(i32),
    Error(String),
}

#[no_mangle]
pub extern "C" fn get_status() -&gt; Status {
    Status::Ok(200)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Java Side Solution</strong>: To handle this enum, Java needs to use a layout that supports both an <strong>enum tag</strong> (discriminator) and the associated data.</p>
<pre><code class="language-java">StructLayout statusLayout = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName("tag"),     // Enum discriminator
    ValueLayout.JAVA_INT.withName("value")    // Holds Ok value or error pointer
);

VarHandle tagHandle = statusLayout.varHandle(PathElement.groupElement("tag"));
VarHandle valueHandle = statusLayout.varHandle(PathElement.groupElement("value"));

MemorySegment statusSegment = arena.allocate(statusLayout);
int tag = (int) tagHandle.get(statusSegment);

if (tag == 0) {  // Ok variant
    int okValue = (int) valueHandle.get(statusSegment);
    System.out.println("Status OK: " + okValue);
} else {  // Error variant
    // Process error value appropriately
    System.out.println("Status Error");
}
</code></pre>
<h2 id="explanation-and-solution-1"><a class="header" href="#explanation-and-solution-1">Explanation and Solution:</a></h2>
<p><strong>Discriminator and Value Fields</strong>: <code>tag</code> differentiates between <code>Ok</code> and <code>Error</code>, while <code>value</code> holds associated data. By reading <code>tag</code>, Java can branch to handle each case correctly.</p>
<p><strong>Memory Layout Compatibility</strong>: Using a <code>StructLayout</code> with specific <code>VarHandles</code> ensures memory alignment and prevents misinterpretation of data.</p>
<h2 id="why-its-tricky-1"><a class="header" href="#why-its-tricky-1">Why It’s Tricky:</a></h2>
<p>Enums in Rust can carry various data types for each variant, which Java enums don’t support. The solution requires careful layout management and handling each variant’s data accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrongmethodtypeexception-in-invokeexact"><a class="header" href="#wrongmethodtypeexception-in-invokeexact">WrongMethodTypeException in <code>invokeExact()</code></a></h1>
<p><strong>Cause</strong>: Java’s <code>MethodHandle.invokeExact()</code> requires an exact match between arguments and the function signature. A mismatch in argument types or order will throw this error.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>Verify <code>FunctionDescriptor</code>: Ensure that the <code>FunctionDescriptor</code> matches the Rust function’s expected argument and return types exactly.</li>
<li>Check Argument Casts: Explicitly cast arguments to their expected types, and cast return values as needed.</li>
</ol>
<h2 id="example-3"><a class="header" href="#example-3">Example:</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust function signature: pub extern "C" fn add(x: i32, y: i32) -&gt; i32
FunctionDescriptor addDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT);
MethodHandle addHandle = linker.downcallHandle(lib.find("add").orElseThrow(), addDescriptor);

int result = (int) addHandle.invokeExact(5, 3);  // Cast to int as expected
<span class="boring">}</span></code></pre></pre>
<h2 id="explanation-and-solution-2"><a class="header" href="#explanation-and-solution-2">Explanation and Solution:</a></h2>
<p><strong>Type Matching</strong>: <code>FunctionDescriptor</code> ensures that Java and Rust types align.</p>
<p><strong>Exact Casting</strong>: Casting return values and arguments to their exact types avoids this error, as Java’s type system is stricter here than Rust’s.</p>
<h2 id="why-its-tricky-2"><a class="header" href="#why-its-tricky-2">Why It’s Tricky:</a></h2>
<p>Rust function signatures may allow implicit casting that Java does not, so ensuring exact types in the descriptor is essential.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segmentation-fault-or-undefined-behavior"><a class="header" href="#segmentation-fault-or-undefined-behavior">Segmentation Fault or Undefined Behavior</a></h1>
<p><strong>Cause</strong>: This typically results from misaligned memory or accessing freed memory. Common causes include mismatched layouts, accessing unallocated memory, or not using the correct arena.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li><strong>Verify <code>MemoryLayout</code> Alignment</strong>: Ensure <code>MemoryLayout</code> precisely matches Rust’s struct or array layout, particularly if <code>#[repr(C)]</code> is used.</li>
<li><strong>Use Arenas Appropriately</strong>: Manage memory with confined or auto arenas to ensure data remains valid only as long as needed.</li>
</ol>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p><strong>In Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct Data {
    x: i32,
    y: i64,
}

#[no_mangle]
pub extern "C" fn create_data() -&gt; *mut Data {
    Box::into_raw(Box::new(Data { x: 1, y: 2 }))
}
<span class="boring">}</span></code></pre></pre>
<p><strong>In Java</strong>:</p>
<pre><code class="language-java">StructLayout dataLayout = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName("x"),
    ValueLayout.JAVA_LONG.withName("y")
);

var arena = Arena.ofConfined();
MemorySegment dataSegment = arena.allocate(dataLayout);
MethodHandle createData = RustBindings.createDataHandle();
dataSegment = (MemorySegment) createData.invokeExact();
</code></pre>
<h2 id="explanation-and-solution-3"><a class="header" href="#explanation-and-solution-3">Explanation and Solution:</a></h2>
<p><strong>Alignment Matching</strong>: Ensure <code>JAVA_INT</code> and <code>JAVA_LONG</code> are aligned with Rust’s <code>i32</code> and <code>i64</code>. Java’s layout must match precisely, as alignment affects performance and stability.</p>
<p><strong>Safe Memory Access</strong>: Use confined arenas to allocate and manage Rust data safely, freeing memory once Java no longer requires it.</p>
<h2 id="why-its-tricky-3"><a class="header" href="#why-its-tricky-3">Why It’s Tricky:</a></h2>
<p>Alignment and memory lifetime issues can cause silent data corruption or segmentation faults, making layout precision and memory management critical for stability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsatisfiedlinkerror-when-loading-rust-shared-library"><a class="header" href="#unsatisfiedlinkerror-when-loading-rust-shared-library">UnsatisfiedLinkError When Loading Rust Shared Library</a></h1>
<p><strong>Cause</strong>: Java cannot find the Rust shared library file (e.g., <code>.so</code>, <code>.dll</code>, <code>.dylib</code>) because the file path is incorrect or the library name is misspelled.</p>
<p><strong>Solution</strong></p>
<ol>
<li><code>Specify Library Path and Name Correctly</code>: Ensure that the shared library file is available in the system path or specified explicitly.</li>
<li><code>Check System Compatibility</code>: Ensure that the library file matches the OS format (e.g., .dll on Windows).</li>
</ol>
<h2 id="example-5"><a class="header" href="#example-5">Example:</a></h2>
<pre><code class="language-java">// Ensure correct file name for your OS
SymbolLookup lib = SymbolLookup.libraryLookup("libmylibrary.so", Arena.global());
</code></pre>
<h2 id="explanation-and-solution-4"><a class="header" href="#explanation-and-solution-4">Explanation and Solution:</a></h2>
<p><strong>Library Path Validation</strong>: Confirm that the library file path is correct, and the file exists. Specifying the full path or ensuring the library is on the system’s path will solve this issue.</p>
<h2 id="why-its-tricky-4"><a class="header" href="#why-its-tricky-4">Why It’s Tricky:</a></h2>
<p>If Java cannot locate the Rust library, it throws a runtime error, which can be hard to trace if the path is only slightly incorrect.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-layout"><a class="header" href="#value-layout">Value Layout</a></h1>
<p><code>ValueLayout</code> is the most primitive layout type, representing the layout of,
well, primitives. They are:
<br></p>
<ol>
<li>ValueLayout.ADDRESS</li>
<li>ValueLayout.JAVA_BOOLEAN</li>
<li>ValueLayout.JAVA_BYTE</li>
<li>ValueLayout.JAVA_CHAR</li>
<li>ValueLayout.JAVA_DOUBLE</li>
<li>ValueLayout.JAVA_FLOAT</li>
<li>ValueLayout.JAVA_INT</li>
<li>ValueLayout.JAVA_LONG</li>
<li>ValueLayout.JAVA_SHORT</li>
<li>ValueLayout.ADDRESS_UNALIGNED</li>
<li>ValueLayout.JAVA_CHAR_UNALIGNED</li>
<li>ValueLayout.JAVA_DOUBLE_UNALIGNED</li>
<li>ValueLayout.JAVA_FLOAT_UNALIGNED</li>
<li>ValueLayout.JAVA_INT_UNALIGNED</li>
<li>ValueLayout.JAVA_LONG_UNALIGNED</li>
<li>ValueLayout.JAVA_SHORT_UNALIGNED</li>
</ol>
<p>These all correspond to the Java
primitives (<code>ADDRESS</code> is a bit special), <a href="size_and_alignment.html">aligned and unaligned</a>, which have
direct mappings to C primitive types.<br />
<br></p>
<div class="table-wrapper"><table><thead><tr><th><strong>Java Type</strong></th><th><strong>C Type</strong></th><th><strong>Rust Type</strong></th></tr></thead><tbody>
<tr><td>ValueLayout.ADDRESS</td><td>pointer</td><td>pointer or Option&lt;reference&gt;</td></tr>
<tr><td>ValueLayout.ADDRESS_UNALIGNED</td><td>pointer with alignment 1</td><td>ditto with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_BOOLEAN</td><td>char but must be 0 or 1</td><td>bool</td></tr>
<tr><td>ValueLayout.JAVA_BYTE</td><td>char</td><td>i8</td></tr>
<tr><td>ValueLayout.JAVA_CHAR</td><td>short storing a UTF-16 codepoint</td><td>u16 storing a UTF-16 codepoint</td></tr>
<tr><td>ValueLayout.JAVA_CHAR_UNALIGNED</td><td>ditto with alignment 1</td><td>ditto with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_DOUBLE</td><td>double</td><td>f64</td></tr>
<tr><td>ValueLayout.JAVA_DOUBLE_UNALIGNED</td><td>f64 with alignment 1</td><td></td></tr>
<tr><td>ValueLayout.JAVA_FLOAT</td><td>float</td><td>f32</td></tr>
<tr><td>ValueLayout.JAVA_FLOAT_UNALIGNED</td><td>float with alignment 1</td><td>f32 with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_INT</td><td>int</td><td>i32</td></tr>
<tr><td>ValueLayout.JAVA_INT_UNALIGNED</td><td>int with alignment 1</td><td>i32 with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_LONG</td><td>long</td><td>i64</td></tr>
<tr><td>ValueLayout.JAVA_LONG_UNALIGNED</td><td>long with alignment 1</td><td>i64 with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_SHORT</td><td>short</td><td>i16</td></tr>
<tr><td>ValueLayout.JAVA_SHORT_UNALIGNED</td><td>short with alignment 1</td><td>i16 with alignment 1</td></tr>
</tbody></table>
</div><br>  
<p>So the <code>_UNALIGNED</code> versions are exactly the same as their counterparts
except that they have an alignment of 1. This allows storing them unaligned,
but it will also force the JVM to issue special instruction sequences to load
values, since most CPU architectures do not natively support unaligned loads
and stores from or to memory. It is also worth noting that
<code>ValueLayout.JAVA_DOUBLE</code> and <code>ValueLayout.JAVA_LONG</code> have
platform-dependent alignment because some CPU architectures require
natural alignment (size = alignment, so 8 in this case) whereas some like
x86 only require an alignment of 4. All other primitives are defined to have
natural alignment.</p>
<p>Beyond representing primitive types, <code>ValueLayouts</code> also provide access to
different byte <a href="orderings.html">ordering</a> (also known as endianness) through the
<code>.withOrder(ByteOrder)</code> method. The choices for <code>ByteOrder</code> are <code>BIG_ENDIAN</code>,
and <code>LITTLE_ENDIAN</code>, although the static method <code>ByteOrder.nativeOrder()</code>
will return whichever of those your CPU natively uses (usually
<code>LITTLE_ENDIAN</code>). This is required by many serialization formats, such as
most network formats, because many of them require <code>BIG_ENDIAN</code> byte
order while most CPU architectures only natively support <code>LITTLE_ENDIAN</code>.
Rust doesn’t have <code>int</code>, <code>long</code>, etc., so we must use a different translation to</p>
<p>For additional information on <code>ValueLayout</code>, visit Oracle's <a href="https://cr.openjdk.org/~mcimadamore/jdk/FFM_22_PR/javadoc/java.base/java/lang/foreign/ValueLayout.html">official documentation</a>, and official Rust resource <a href="https://doc.rust-lang.org/nomicon/"><em>The Rustonomicon</em></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-handle"><a class="header" href="#method-handle">Method Handle</a></h1>
<p>MethodHandle is where one of the most essential tools in the <a href="https://openjdk.org/jeps/454">FFM API</a>
. The absolute most important method on MethodHandles returned from the <code>Linker</code> is <code>invokeExact(…)</code>.
<code>.invokeExact(…)</code> takes in the parameters of the function according to the
<a href="function_descriptor.html"><code>FunctionDescriptor</code></a> and returns a value with type also specified by the
<code>FunctionDescriptor</code>. Java will throw an exception at runtime if the arguments
passed to the method do not match up with the <code>FunctionDescriptor</code>. Because
of some Java Virtual Machine details, the return
value must also be explicitly cast to the expected return type. Otherwise, Java will once again throw an exception at
runtime, this time because the return type was wrong. A
function with signature <code>FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_FLOAT)</code> would be called like so:<br />
<code>int returnValue = (int)handleName.invokeExact(myFloat)</code>.</p>
<p>For more information on <code>MethodHandle</code>, visit Oracle's <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/MethodHandle.html">official documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-layout"><a class="header" href="#memory-layout">Memory Layout</a></h1>
<p>Memory Layouts can be used in
order to streamline the allocation of off-heap memory. Here is an overview
of how <code>MemoryLayout</code> differs from <a href="memory_segment.html"><code>MemorySegment</code></a>.</p>
<p>Assume an array of structs needs to be declared for the following example. First an
<a href="arenas.html"><code>Arena</code></a> must be created, any arena type desired will do. Next a
<code>MemoryLayout.sequenceLayout()</code> can be used, with arguments n, that reflect the length
of the array, and <code>MemoryLayout.structLayout()</code>, that takes in the
<a href="value_layout.html">value layouts</a> and names of elements within the struct. After this, create
<a href="variable_handle.html"><code>VarHandles</code></a> for each element within the struct, which create a reference for
each respective element. Then create a <code>MemorySegment</code> that
corresponds to the entire memory layout of the array, and allocate it to the
appropriate arena, and finally the structs can be accessed.</p>
<p>For additional information on <code>MemoryLayout</code>, visit Oracle's <a href="https://cr.openjdk.org/~mcimadamore/jdk/FFM_22_PR/javadoc/java.base/java/lang/foreign/MemoryLayout.html">official documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-segment"><a class="header" href="#memory-segment">Memory Segment</a></h1>
<p><code>MemorySegment</code> represents a fat pointer, that is, a pointer with associated
bounds information, much like a mutable slice in Rust. The main method
associated with memory segments is <code>.get(</code><a href="memory_layout.html"><code>MemoryLayout</code></a><code>, offset)</code>, which
indexes offset amount into the pointer and reads whatever memory is there
as if it’s of the associated type.</p>
<p>For instance,
<code>segment.get(</code><a href="value_layut.html"><code>ValueLayout</code></a><code>.JAVA_INT, 1)</code> is basically the same as C code doing
<code>((int*)segment)[1]</code>. The only difference from the C code is that Java will
throw an exception if the program attempts to access an index outside of the
bounds associated with the <code>MemorySegment</code>. The most common sources of
MemorySegments are functions returning pointers. <code>MemorySegments</code>
returned to Java through the foreign function interface will automatically be
assigned a length of zero, since Java does not have enough information to
determine the bounds. However, invoking the <code>.reinterpret(size)</code> method will
edit the bounds information. This is extremely unsafe and must
be used with caution. Assigning a logically incorrect bound
could allow normal Java code to cause a segmentation fault (or worse).</p>
<p>Finally, like Rust slices, <code>MemorySegments</code> can be subsliced using
<code>.asSlice(offset, size)</code>, which is also bounds-checked, returning a new slice
with the associated pointer and length values and the same <a href="lifetimes.html">lifetime</a> as the
original.</p>
<p>For more information on <code>MemorySegment</code>, visit Oracle's <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemorySegment.html">official documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variable-handle"><a class="header" href="#variable-handle">Variable Handle</a></h1>
<p>A <code>VarHandle</code> represents a handle to a sub-layout given a layout. It helps
solve the problem of, say, accessing an <code>int</code> field of a struct, or accessing
an element of an array. Variable handles are used to construct a path to a value
that needs to be given a certain layout (basically a type). Say there is a pointer to
an array of struct <code>foo</code>, which has an integer member <code>x</code> that must be read.
This is how to construct a <code>VarHandle</code> to get <code>x</code> from any such
pointer:</p>
<pre><code class="language-java">MemoryLayout layoutOfPointer =
ValueLayout.ADDRESS.withTargetLayout(
    MemoryLayout.sequenceLayout(arrayLen,
        MemoryLayout.structLayout(
            ValueLayout.JAVA_INT.withName(“x”),
            ValueLayout.JAVA_INT.withName(“y”),
        )
    )
);
VarHandle xHandle = layoutOfPointer.varHandle(
    PathElement.dereferenceElement(),
    PathElement.sequenceElement(),
    PathElement.groupElement(“x”)
);
</code></pre>
<p>Now whenever <code>x</code> is needed from this kind of pointer,  call
<code>(int)xHandle.get(</code><a href="memory_segment.html"><code>MemorySegment</code></a><code>, 0, index)</code>.</p>
<p>For more information on <code>VariableHandle</code>, visit Oracle's <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/VarHandle.html">official documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-descriptor"><a class="header" href="#function-descriptor">Function Descriptor</a></h1>
<p>FunctionDescriptor represents the signature of a function.<br />
<code>FunctionDescriptor.of(MemoryLayout, … )</code> takes a variadic<sup class="footnote-reference"><a href="#variadic">1</a></sup> input of
<a href="memory_layout.html"><code>MemoryLayouts</code></a>. The first argument is the memory layout of the return
type, and the rest correspond to the memory layouts of the function
arguments.</p>
<p>For example, <code>int foo(float, void*)</code> would be represented as
<code>FunctionDescriptor.of(</code><a href="value_layout.html"><code>ValueLayout</code></a><code>.JAVA_INT, ValueLayout.JAVA_FLOAT, ValueLayout.ADDRESS)</code></p>
<p>For void functions,
<code>FunctionDescriptor.ofVoid(MemoryLayout, … )</code> is a static method that is
exactly the same as <code>FunctionDescriptor.of(MemoryLayout, … )</code> except that its
first argument corresponds to the first function argument rather than the
return value.</p>
<p>For example, <code>void foo(float, void*)</code> would translate to
<code>FunctionDescriptor(ValueLayout.JAVA_FLOAT, ValueLayout.ADDRESS)</code></p>
<p>For additional information on <code>FunctionDescriptor</code>, visit Oracle's <a href="https://cr.openjdk.org/~asotona/JDK-8308753-preview/api/java.base/java/lang/foreign/FunctionDescriptor.html">official documentation</a>.</p>
<div class="footnote-definition" id="variadic"><sup class="footnote-definition-label">1</sup>
<p>The function can take a variable amount of arguments</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-layout"><a class="header" href="#struct-layout">Struct Layout</a></h1>
<p>A <code>StructLayout</code> represents the layout of a C-style struct, including the layout
of all its members, all their members (if applicable), and so on. It does
exactly the same job as a struct definition in C. The class itself has no
interesting methods, but you can create a StructLayout using
<code>MemoryLayout.structLayout(MemoryLayout…)</code>. To translate the following
structs to the Java <a href="https://openjdk.org/jeps/454">FFM API</a>, we would use the
following Java code:</p>
<p>C:</p>
<pre><code class="language-c">struct foo {
    int num;
    char* string;
    struct bar baz;
}
</code></pre>
<p>Java:</p>
<pre><code class="language-java">StructLayout bar = …;
StructLayout foo = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName(“num”),
    ValueLayout.ADDRESS.withTargetLayout(0,
        ValueLayout.JAVA_BYTE).withName(“string”),
    bar.withName(“baz”)
);
</code></pre>
<p>The <code>.withName(String)</code> method allows you to later retrieve a <a href="variable_handle.html"><code>VarHandle</code></a>
using that name, covered in the <code>VarHandle</code> section.
Constructing a <code>StructLayout</code> like this will automatically generate the
appropriate total <a href="size_and_alignment.html">size and alignment</a>, as well as member offsets and padding
that C would add on this platform. Generally, the size is greater than or
equal to the sum of the sizes of the members (making room for padding as
necessary to keep all members aligned) and the alignment is the maximum
of the member alignments. Some exotic C programs may use overaligned
structs<sup class="footnote-reference"><a href="#note">1</a></sup>, for which you can add a final
<code>.withAlignment(alignment)</code> to override the automatic alignment calculated by
Java.</p>
<p>This all still applies to Rust, but only on:</p>
<ol>
<li><code>#[repr(C)]</code> structs</li>
<li><code>#[repr(C)]</code> tuple structs<sup class="footnote-reference"><a href="#tuple">2</a></sup></li>
<li><code>#[repr(integer type)]</code> enums with only valueless variants</li>
<li>enums with
exactly one nonnullable <code>#[repr(C)]</code> variant and up to one zero-sized variant<sup class="footnote-reference"><a href="#note2">3</a></sup></li>
<li><code>#[repr(transparent)]</code> structs and tuple structs with exactly one <code>#[repr(C)]</code> member and all other members being zero-sized</li>
</ol>
<p><code>#[repr(C)]</code> requires all members, and members of members, and members of those members, etc. to be <code>#[repr(C)]</code> as well, which is very
invasive to code. For the sake of performance, some may choose to do this,
but it also greatly limits what you can use in the standard library.
Common non <code>#[repr(C)]</code> types include:</p>
<ol>
<li><code>Vec</code></li>
<li><code>String</code></li>
<li><code>&amp;str</code></li>
<li>slices</li>
<li>anonymous</li>
<li>tuples</li>
<li><code>dyn</code> references</li>
<li><code>Box&lt;dyn T&gt;</code></li>
<li>most enums with a variant that holds a value (<code>Option&lt;T&gt;</code> for most <code>T</code>)</li>
<li>all enums with more than one variant that holds a value</li>
<li>every single container type<sup class="footnote-reference"><a href="#container">4</a></sup></li>
</ol>
<p>If a type uses any of these types (and most types from external libraries too) by
value, that type cannot be <code>#[repr(C)]</code>. The only way around this restriction
is through pointer indirection, like <code>Box&lt;T&gt;</code><sup class="footnote-reference"><a href="#box">5</a></sup>, because pointers are always
representable even if the thing they are pointing to is not. People wanting
every last ounce of performance can deal with this, but the average Rust
type cannot, and so it cannot be represented as a <code>StructLayout</code> or a
<a href="memory_layout.html"><code>MemoryLayout</code></a>. The last class important specifically to <code>StructLayout</code> is <code>PaddingLayout</code>. This is the layout of padding in StructLayouts. It exists purely to pad
the struct.</p>
<p>For more information on <code>StructLayout</code>, visit Oracle's <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/StructLayout.html">official documentation</a>.</p>
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>Many compilers accept <code>__attribute__((aligned(x)))</code> to align a struct
to <code>x</code>, or they keep its original alignment if <code>x</code> is less than or equal to that. Rust
has <code>#[align(x)]</code> to specify overalignment.</p>
</div>
<div class="footnote-definition" id="tuple"><sup class="footnote-definition-label">2</sup>
<p>Tuple structs are just structs with anonymous members.</p>
</div>
<div class="footnote-definition" id="note2"><sup class="footnote-definition-label">3</sup>
<p>This case exists pretty much purely to allow Option<reference> to be
exchanged as a nullable pointer</p>
</div>
<div class="footnote-definition" id="container"><sup class="footnote-definition-label">4</sup>
<p><code>VecDeque</code>, <code>HashMap</code>, <code>HashSet</code>,
<code>BTreeMap</code>, <code>BTreeSet</code>, every iterator in the entire standard library, every IO
type, every FS type (including <code>File</code>), <code>Rc</code>, <code>Arc</code>, <code>RefCell</code>, <code>RwLock</code>, <code>Mutex</code>.</p>
</div>
<div class="footnote-definition" id="box"><sup class="footnote-definition-label">5</sup>
<p>Still doesn’t work for <code>dyn</code>, use
<code>ThinBox</code> for that. <code>Box&lt;T&gt;</code> is guaranteed to be represented by just a pointer,
semantically like one returned from malloc.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union-layout"><a class="header" href="#union-layout">Union Layout</a></h1>
<p><code>UnionLayout</code> represents a C union. Much like a C union, it is used to specify and
access the different members like it was a struct. However, only one of
those members exists at any one time. You can create a <code>UnionLayout</code> with
<a href="memory_layout.html"><code>MemoryLayout</code></a><code>.unionLayout(MemoryLayout…)</code>. Just like in C, a
<a href="memory_segment.html"><code>MemorySegment</code></a> referencing a <code>UnionLayout</code> can be treated as actually referencing the
layout of one of its members, such as by calling <code>.get()</code> with the associated
<code>MemoryLayout</code>.</p>
<p>Alternatively, <a href="variable_handle.html">Variable Handles</a> can be used to
reference members
in a process similar to that used in C.
Generally, union layouts will have a <a href="size_and_alignment.html">size</a> equal to the maximum size of its
members and an <a href="size_and_alignment.html">alignment</a> equal to the maximum alignment of its
members. Similarly to structs, unions can be overaligned, which can be
specified by adding <code>.withAlignment(alignment)</code> to the end of the method
chain to overwrite Java’s automatically-determined alignment for that type.</p>
<p>For more information on <code>UnionLayout</code>, visit Oracle's <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/MethodHandle.html">official documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-layout"><a class="header" href="#sequence-layout">Sequence Layout</a></h1>
<p><code>SequenceLayout</code> represents the layout of arrays. To create a
<code>SequenceLayout</code>, call <a href="memory_layout.html"><code>MemoryLayout</code></a><code>.sequenceLayout(numberOfElements, MemoryLayout)</code>. There is no get method or any direct way to get the nth
element of an array. Instead, create a special <a href="variable_handle.html"><code>VarHandle</code></a> to the needed
data within the member, then call get on that with the index. For instance, to
get the x-coordinates of the structs in an array, use:</p>
<pre><code class="language-java">SequenceLayout arrayOfStruct = MemoryLayout.sequenceLayout(10,
    MemoryLayout.structLayout(
        ValueLayout.JAVA_INT.withName(“x”),
        ValueLayout.JAVA_INT.withName(“y”)
    ).withName(“struct”)
);
VarHandle varHandle =
arrayOfStruct.arrayElementVarHandle(PathElement.groupElement(“x”));
for (int i=0; i&lt;10; i++) {
    System.out.println(varHandle.get(memorySegment, 
        0L,
        (long)i)
    );
}
</code></pre>
<p><code>SequenceLayout</code> provides some interesting <strong>methods</strong>.
<code>sequenceLayout.elementCount()</code> will, as the name suggests, give the
length of the array, which is useful for passing around slices as it is not necessary to store the length itself.
<code>sequenceLayout.reshape(long dim1, long dim2, …)</code> and <code>sequenceLayout.flatten()</code> are both related to reinterpreting
multidimensional arrays. Multidimensional arrays are just arrays of arrays,
but their layout means they can safely be reinterpreted as a single
dimension array of <a href="size_and_alignment.html">size</a> <code>(dim 1 size)*(dim 2 size)*...</code>, which is exactly what
<code>sequenceLayout.flatten()</code> does. <code>sequenceLayout.reshape</code> does the inverse of
<code>sequenceLayout.flatten()</code>, but is also fallible. Obviously, if an attempt is made to reshape
an array to AxBxC but the array’s length isn’t divisible by A and B and C, this
method will throw an exception. Another nice property of
<code>sequenceLayout.reshape()</code> is that one argument may be set to -1, in which
case <code>sequenceLayout.reshape()</code> will do the math based on the array’s length
to determine what that dimension must be.</p>
<p>A Java type can be used to act as a wrapper around <strong>Rust slices</strong>, so
<code>SequenceLayout</code> would feature heavily in that kind of implementation. While
a slice object, composed of a pointer and a length, is not application binary
interface (ABI) stable, the underlying array is ABI stable.
Rust provides methods to get the pointer and length from a slice, as well as
functions to construct slices from a pointer and a length, so while it is not
ABI safe, it is easy enough to disassemble and
reassemble into safe forms as needed. While it is easier to just keep an
opaque blob of data and ask Rust any time it must be used, it is much
faster for Java to have direct access to the array.</p>
<p>The <strong>Just-In-Time</strong> (JIT) compiler knows how array accesses work, and can optimize
the corresponding Java code, possibly with automatic vectorization which is
a great boost to throughput. In contrast, every time a call is made out to a Rust
function, the JIT compiler has no idea what that function is doing.
This means that it can not optimize the memory accesses, and it must also assume
that the function breaks every optimization assumption it has. For instance, the
function could touch any value in memory, preventing the JIT
compiler from reordering any reads or writes from before the function call to
after the function call, and vise versa.</p>
<p>The <strong>Rust compiler</strong> has the same issue: it
does not know what the Java code is doing, so there is no way it can optimize
around that such as automatic vectorization either. This does not matter so
much for one-off functions, functions that are only called a few thousand
times, or large functions where execution time is dominated by actually
running the function and not on function call overhead, but for simple code
in loops this can be brutal. And how are arrays typically
used? Usually small bits of code run many times in a loop. The performance
gains are too great to ignore. While doing the loop in Rust will beat Java
almost every time, it is not reasonable for every possible loop body to be put
in Rust. However, developers have the option to write all of their
loops in Rust if they so choose. Still, <code>SequenceLayout</code>
provides a great opportunity to allow easy, direct access to arrays and
array elements for Java.</p>
<p>For more information on <code>SequenceLayout</code>, visit Oracle's <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/SequenceLayout.html">official documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arenas"><a class="header" href="#arenas">Arenas</a></h1>
<p>Arenas are a way that Java provides developers to allocate memory in a way
that is particularly useful for creating bindings. Arenas are like a
stack of memory, and its space can be split in various ways, and its <a href="lifetimes.html">lifetime</a>
can be set by various types. The main idea of where arenas can be used is
that they can create space to store objects in Java called <a href="memory_segment.html">Memory Segments</a>. These memory segments can store data such as
variables, data structures, and functions in a space that the garbage
collector treats differently. That means information stored in
these arenas can be passed to and from foreign functions without worrying about
whether Java’s garbage collector has tampered with the space.</p>
<p>There are four different types of arenas: confined, automatic, shared,
and custom. Confined arenas and shared arenas are very similar. They both will live as
long as the Java program unless they are manually closed by the user using
the <code>.close()</code> method on the arena object. The key difference between the
two is that confined arenas can only be accessed by a single thread, while
shared arenas can be accessed by multiple threads. This causes a weird
interaction with shared arenas. When a confined arena is closed, its memory
is immediately freed and that’s all there is to it. When a shared arena is
closed, it invalidates all Java references to the space in memory, but it does
not immediately free it as the process takes longer, meaning that the space
in memory is technically alive for a very short amount of time after the
arena is closed. These arenas are useful for creating Rust bindings because they can
guarantee a space in memory cannot be accessed once closed, so they can be
implemented into functions to guarantee proper memory safety practices.</p>
<p>The API descriptions for automatic arenas typically vaguely describe their closing
behavior, such as “the garbage collector eventually frees it automatically”.
To better describe its behavior, The garbage collector will only free the automatic
arena either at the end of the Java program or when it determines that the
arena is unreachable. But what does the garbage collector see as unreachable?</p>
<p>Testing will show that Java will not close the arena even if every
memory segment inside is set to null. The information inside the arena
has no bearing on the garbage collector’s decision to keep it around. However, a way
to guarantee that the garbage collector determines the arena as unreachable is to set
the arena to null. This means that automatic arenas can be useful and reliable for
creating bindings as well, especially if it is not clear when a certain arena should
be closed. The only downside of the automatic arena is its interaction with the
garbage collector. It is possible this could cause some sort of increased overhead.</p>
<p>With an Arena, you can call <code>arena.allocate(</code><a href="size_and_alignment.html"><code>size, alignment</code></a><code>)</code> to allocate
memory within the arena. Allocations cannot be individually freed with
Arenas, it’s either all or nothing. Global Arenas
are useful for set-and-forget things, like for loading the Rust library, since this
does not need to be freed. Confined Arenas are good for data that cannot be
safely shared across threads, so for types that don’t implement the
<a href="send_and_sync.html">Send trait</a>. Auto Arenas are nice if it is difficult to figure out
when something should be deallocated. Although this isn’t very common as <code>drop()</code>
should be called on Rust objects that require cleanup, and Java’s
garbage collector will not take care of this.</p>
<p>For more information on arenas, visit Oracle's <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html">official documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-object-and-dynamic-library-files"><a class="header" href="#shared-object-and-dynamic-library-files">Shared Object and Dynamic Library Files</a></h1>
<p>Shared object and dynamic library files effectively serve the same purpose in this
scope. They provide executable code to outside sources. This means that once Java is
given the address to the code for a function in this file, it is ready to run once
called. Although they effectively share the same purpose, their file types differ
based on the system running. Below is a table with each file extension used by three
of the most common operating systems.</p>
<br>  
<div class="table-wrapper"><table><thead><tr><th><strong>System</strong></th><th><strong>File Extension</strong></th></tr></thead><tbody>
<tr><td>Linux</td><td>.so</td></tr>
<tr><td>Windows</td><td>.dll</td></tr>
<tr><td>Mac</td><td>.dylib</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>A piece of data must be owned by at most one variable at any given time,
even across an FFI boundary. If Rust has ownership of a <code>Vec&lt;T&gt;</code> for
instance, Java cannot decide to take control of it, as, in this case, that would
lead to both Java and Rust calling drop when done with the type, causing a
double free of the backing array. And that’s one of the better outcomes, as
generally types do not expect to suddenly be in an invalid state due to
external mucking, nor is there much they can do about it. One exception to
this rule are types that implement Copy, as they can be blindly memcopied
to create an identical clone of the original (barring any atomicity issues if
this is done across threads), though most types do not implement Copy so
this isn’t very useful when creating these bindings.</p>
<h2 id="example-of-ownership"><a class="header" href="#example-of-ownership">Example of Ownership</a></h2>
<p>In this calculator code, ownership is demonstrated in how PostfixCalculator
manages its stack:</p>
<pre><code class="language-rust ignore">struct PostfixCalculator {
    stack: VecDeque&lt;f64&gt;,
}

impl PostfixCalculator {
    fn new() -&gt; Self {
        PostfixCalculator {
            stack: VecDeque::new(),
        }
    }
}</code></pre>
<p>PostfixCalculator owns its stack. When PostfixCalculator is
dropped, so is its stack, which automatically cleans up without the
programmer needing to manually manage memory.</p>
<p>To learn more about ownership, it is recommended to read these official Rust
resources: <em>The Rust Programming Language</em> chapter
<a href="https://rust-book.cs.brown.edu/ch04-00-understanding-ownership.html">4</a>, and <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/obrm.html">6</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing-and-aliasing"><a class="header" href="#borrowing-and-aliasing">Borrowing and Aliasing</a></h1>
<p>Data can be “borrowed” as references, either immutably <code>&amp;T</code> or mutably
<code>&amp;mut T</code>. The compiler enforces a sort of reader-writer lock on the type: it
can have either multiple readers (immutable/shared references, <code>&amp;T</code>) or a
singular writer (mutable/exclusive reference, <code>&amp;mut T</code>). The compiler will
assume that the data behind a shared reference will not mutate (unless the
type opts out of it with <code>UnsafeCell</code>, which can be used for custom special
types, which should not be used to enforce users’ types) and the compiler
will assume that no other code or data can reference, read, or mutate the
data behind an exclusive reference (there is no opt out, this must never
happen!). The fact that Rust can make these assumptions is what makes it
so fast and efficient, but it also means you are restricted from coding practices
that break them.</p>
<p>This is approximately the exact opposite of Java’s memory model, where
everything is a mutable reference to the underlying object. While Java can’t
arbitrarily clone objects, meaning it can’t make copies of a class holding an
exclusive reference, it can make those objects live arbitrarily long. This
means it is essential to either detect that the reference is still live and refuse to
service any other borrows, or invalidate the reference in order to service
other borrows. There is a Rust type that effectively performs this latter
approach: <code>RefCell&lt;T&gt;</code>.</p>
<p>Raw pointers in Rust do not have such aliasing restrictions with regard to
each other, so we are free to have any number of constant <code>*const T</code> and
mutable <code>*mut T</code> pointers coexisting. Raw pointer semantics are just like
they are in C, and are in fact even more lenient than C pointers since C
pointers of differing types are not allowed to alias. You’re still not allowed to
mess with ownership – the owner of the type still acts like your pointers
don’t exist and so still assumes it is the arbiter of reads and writes – but if
you have ownership of the type you can just make sure to only interact with
it using raw pointers. This is exactly what <code>UnsafeCell&lt;T&gt;</code> and <code>Cell&lt;T&gt;</code> do to
enable shared mutability, and those are the primitives fancy types like
<code>Rc&lt;T&gt;</code> use to allow shared ownership.</p>
<h2 id="example-of-borrowing-and-aliasing"><a class="header" href="#example-of-borrowing-and-aliasing">Example of Borrowing and Aliasing</a></h2>
<p>In this calculator code, Borrowing and Aliasing is demonstrated.</p>
<pre><code class="language-rust ignore">struct PostfixCalculator {
    stack: VecDeque&lt;f64&gt;,
}

impl PostfixCalculator {
    fn new() -&gt; Self {
        PostfixCalculator {
            stack: VecDeque::new(),
        }
    }
}</code></pre>
<p>Rust's borrowing rules ensure that references to
data (borrowing) do not outlive the data they reference (ownership).
This prevents dangling pointers</p>
<p>To learn more about borrowing and aliasing, it is recommended to read these official Rust
resources: <em>The Rust Programming Language</em> chapter
<a href="https://rust-book.cs.brown.edu/ch04-02-references-and-borrowing.html">4.2</a>, and <em>The Rustonomicon</em> chapters <a href="https://doc.rust-lang.org/nomicon/">3.1 and 3.2</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>Rust constantly wants to know "what exactly is that reference referencing?". Most
things don’t live
forever, so Rust also checks that developers don’t try to use it or reference it
after it has been moved. A move is a change in <a href="ownership.html">ownership</a> which potentially means
physically moving it in memory and invalidating any pointers to it. <code>drop()</code>,
for instance, takes ownership of an object so it can kill it. Anyone familiar
with pointers in C has a decent understanding of the concept of
pointer lifetimes: do not use the pointer after the object has been deleted or
moved. As long as a shared reference exists, no mutable references may exist
and the object must not be moved; and as long as a mutable reference
exists, no other references may exist and the object must not be moved.
The compiler enforces a more stringent test on safe code, that breaking
those rules must provably never happen, leading to some cases where you
know it will not happen, yet the compiler can not prove it, so it does not allow
it. Luckily we do not need to follow the compiler’s test, we only need to follow
those simple rules.</p>
<p>Unfortunately, for arbitrary code the lifetimes involved can get quite
intricate. <code>fn foo&lt;’a&gt;(input: &amp;’a) -&gt; TypeWithLifetime&lt;’a&gt;</code> creates a
transitive relationship between the lifetime of input and
<code>TypeWithLifetime&lt;’a&gt;</code>. While we may be able to enforce a simple one-to-one
lifetime relationship, it’s unclear if we can feasibly enforce that A lives as
long as B lives as long as C lives as long as D lives as long as… Certainly, if it
requires invasive changes to types crossing the FFI boundary, such as every
reference in every struct needing to be converted to a <code>RefCell&lt;&amp;T&gt;</code>, that
would be very inconvenient for users.</p>
<h2 id="example-of-lifetimes"><a class="header" href="#example-of-lifetimes">Example of Lifetimes</a></h2>
<p>The code does not explicitly use annotated lifetimes because it does not
require them due to its simplicity. However, the concept is there implicitly:</p>
<pre><code class="language-rust ignore">struct PostfixCalculator {
    stack: VecDeque&lt;f64&gt;,
}

impl PostfixCalculator {
    fn new() -&gt; Self {
        PostfixCalculator {
            stack: VecDeque::new(),
        }
    }
}

fn evaluate(&amp;mut self, tokens: Vec&lt;&amp;str&gt;) -&gt; Result&lt;f64, String&gt;
{
    // use of `self` which has an implicit lifetime
}</code></pre>
<p>This example implicitly uses lifetimes to ensure that references within the
evaluate function do not outlive the PostfixCalculator instance they
reference. Rust's lifetime elision rules automatically handle this in most
cases, but explicit lifetime annotations can be used for more complex
scenarios.</p>
<p>To learn more about lifetimes, it is recommended to read these official Rust
resources: <em>The Rust Programming Language</em> chapter
<a href="https://rust-book.cs.brown.edu/ch10-03-lifetime-syntax.html">10.3</a>, and <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/lifetimes.html">3.3</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbols-extern-generics"><a class="header" href="#symbols-extern-generics">Symbols, Extern, Generics</a></h1>
<p>By default, Rust functions have an undefined <strong>application binary interface</strong> (ABI), thus
they are incompatible with what C expects. Rust functions also have mangled symbol
names<sup class="footnote-reference"><a href="#mangle">1</a></sup>. To
guarantee a C ABI (assuming the types
themselves are C ABI compatible, the next
section provides details on that), the function declaration must be prefixed with
<code>extern “C”</code>. So <br />
<code>extern “C” foo(number: i32) -&gt; i32</code> would be equivalent to the
C function <code>int foo(int number)</code>. To guarantee the symbol name is that of the
function name, like in C, you must annotate the function with the
<code>#[no_mangle] attribute</code>.</p>
<p>However, this does not cover functions with <strong>generic types</strong>. Rust allows
creating functions that act on unknown types, so that a fucntion like <br />
<code>fn add&lt;T: Add&lt;Output=T&gt;&gt;(a: T, b: T) -&gt; T { return a + b; }</code> can be reused
with any type as long as it implements <code>Add</code>. How does the same function
handle multiple types? On the machine code level it doesn’t, that’s why
functions are first monomorphized, creating a version of the function for
every used combination of generic types. Calling <code>add(1u32, 1u32)</code> would
generate a function equivalent to <code>fn add(a: u32, b: u32) -&gt; u32</code>, whereas
calling <code>add(1u8, 1u8)</code> would generate <code>fn add(a: u8, b: u8) -&gt; u8</code>.</p>
<p>Java cannot see generic functions, it only sees monomorphized functions that
exist in the <a href="so.html">shared object file</a>. Rust only generates monomorphizations for
types that are used in that function, so if the Rust library code does not use <code>fn add&lt;T: Add&lt;Output=T&gt;&gt;(a: T, b: T) -&gt; T</code> at all, there are no used generic
types and thus the compiler does not generate anything related to that
function. Even if it did, it can not possibly support every type a programmer
might use, especially if a function had multiple type parameters. <code>fn foo&lt;A, B&gt;()</code> would require the square of the number of possible types. The best thing to do without using <code>dyn pointers</code> is enforcing
wrapper functions without generic parameters:
<code>fn add_u32(a: u32, b: u32) -&gt; u32 { return add::&lt;u32&gt;(a, b); }</code>.</p>
<p>Specifying <code>dyn</code> references in a type instructs the Rust compiler to use <strong>fat
pointers</strong> - pointers that store the normal pointer as well as a pointer to a
vtable containing methods that can be called on the pointer. This works
almost exactly like in C++ with exactly the same tradeoff. There is only
one function in the final binary (no monomorphization needed) but it is not
specialized for a type (so no automatic vectorization on integers for
instance). Additionally, it requires dereferencing the pointer to the vtable, as well as
that function then needing to dereference the real pointer once it is called.
This can lead to memory access / cache missing overhead.</p>
<p>It also breaks a common
idiom: <code>Vec&lt;T&gt;</code>. <code>&amp;dyn Vec&lt;T&gt;</code> can be done, but chances are <code>T</code> will need to be
accessed. If <code>Vec&lt;&amp;dyn T&gt;</code> is used, there will be
<a href="lifetimes.html">lifetime</a> issues and it will be necessary to
restructure everything that touches the vector to deal with <code>Vec&lt;&amp;dyn T&gt;</code>,
even if they otherwise could have used the easier <code>Vec&lt;T&gt;</code>. The biggest issue
with using <code>dyn</code>, however, is that some trait methods simply do not work with
<code>dyn</code>. <a href="https://doc.rust-lang.org/nightly/reference/items/traits.html#object-safety"><em>The Rust Reference</em></a>
specifies the conditions that are required for a method to be object-safe: it
must not return <code>Self</code> directly<sup class="footnote-reference"><a href="#self">2</a></sup> (the compiler doesn’t know the ABI layout of a function with an unknown return type), it must
not take <code>Self</code> as an argument directly<sup class="footnote-reference"><a href="#arg">3</a></sup>, and it must not use any generics beyond <code>Self</code><sup class="footnote-reference"><a href="#gen">4</a></sup>.</p>
<p>A final issue with <code>dyn</code> is that fat pointers do not
have a stable ABI. There is an experimental feature,
<code>ptr_metadata</code>, that allows splitting the pointer and its metadata as well as
creating a fat pointer from a raw pointer and metadata. Although, the Metadata
is not object safe. <code>DynMetadata&lt;dyn T&gt;</code> may have a stable representation
for different <code>T</code><sup class="footnote-reference"><a href="#t">5</a></sup>, but it requires lots of transmuting to make that work and it
might technically be undefined behavior. Ultimately, <code>dyn</code> <strong>saves some code size</strong> at
the expense of <strong>poor ergonomics</strong>, using confusing experimental
Rust features, and performance. Therefore, a developer might just be
better off writing everything in Java instead of trying to interoperate with
Rust code.</p>
<div class="footnote-definition" id="mangle"><sup class="footnote-definition-label">1</sup>
<p>This means the symbol name for a function can not be known.</p>
</div>
<div class="footnote-definition" id="self"><sup class="footnote-definition-label">2</sup>
<p>This is because the compiler does not know the ABI layout of a function with
an unknown return type.</p>
</div>
<div class="footnote-definition" id="arg"><sup class="footnote-definition-label">3</sup>
<p>This is because the compiler does not know the
ABI layout of a function with unknown argument types.</p>
</div>
<div class="footnote-definition" id="gen"><sup class="footnote-definition-label">4</sup>
<p>Ditto ABI of arguments.</p>
</div>
<div class="footnote-definition" id="t"><sup class="footnote-definition-label">5</sup>
<p>This is needed for passing it to Java through the C ABI.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="size-and-alignment"><a class="header" href="#size-and-alignment">Size and Alignment</a></h1>
<p>Allocating a Rust object within Java to pass to Rust functions requires
respecting the type’s <strong>size and alignment</strong>. If the space allocated is
too small that leads to buffer overflows or overreading, but another property is alignment.</p>
<p>An alignment of 2 means that that type must be addressed at an address
that is a multiple of 2. For instance, a 16-bit integer on x86 has an
alignment of 2, and so if you try to load a 16-bit integer from say the address
0x7ffff01, the CPU will throw an exception because that number is not a multiple of 2.
x86 is a little less picky than most other architectures, with the highest
alignment being 4 bytes<sup class="footnote-reference"><a href="#bytes">1</a></sup>, but ARM and most other RISCs align a type to its
size. This all means that Java needs to know the alignment of a type in order
to allocate space for it somewhere.</p>
<p>Some Rust types have well-known
alignments due to matching one-to-one with types defined in the ISA, but
most Rust types have compile-time undefined layout. However, Rust does
provide the compile-time constant functions <code>core::mem::size_of::&lt;T&gt;()</code> and
<code>core::mem::align_of::&lt;T&gt;()</code> for querying the size and alignment of a type.
Unfortunately, types are not guaranteed to maintain their layout across
compilations, especially if the compiler version were to change. Therefore, calls to
these functions must be made in the same compiled library as all users of
them.</p>
<div class="footnote-definition" id="bytes"><sup class="footnote-definition-label">1</sup>
<p>Technically, SIMD vectors have higher alignment
with certain instructions.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subtyping-and-variance"><a class="header" href="#subtyping-and-variance">Subtyping and Variance</a></h1>
<p>As a warning, this section will be complex and type-theory heavy, but the gist for
this scope
is that there
are three types of lifetime relationships:</p>
<ul>
<li>
<p>Covariant: ‘a can be used where a ‘b is expected if ‘a is as long or
longer than ‘b. Shared references are covariant because a longer-living reference than required can always be given. Tree structures
where you can only delete leaves kind of act like this (so a
<code>RefCell&lt;&amp;T&gt;</code> chain of references follows this).</p>
</li>
<li>
<p>Contravariant: ‘a can be used where a ‘b is expected if ‘a lives as long
or shorter than ‘b. This only applies to arguments inside of functions or
closures, so those should be banned from use to avoid any headaches. Closures
aren’t application binary interface safe so they are already banned,
and functions as arguments can be replaced with Java upcalls where
less care is needed.</p>
</li>
<li>
<p>Invariant: ‘a cannot be used, the thing you pass in must live exactly as
long as ‘b. This applies to exclusive references, because Rust allows
you to modify data behind an exclusive reference and potentially
change its lifetime, and the caller would have no idea its lifetime got changed, so
that would fail once the caller tries to use it within
its old lifetime, but outside its new lifetime. If an exclusive reference is
checked for validity first before every time it is used, this can work (it’s
effectively <code>RefCell&lt;&amp;mut T&gt;</code>), but that then still bans every function
that touches an exclusive reference directly. Honestly, this may not be truly
solvable, it might just have to be invasive to the
programmer.</p>
</li>
</ul>
<p>To learn more about subtyping and variance, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/subtyping.html">3.8</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unwinding"><a class="header" href="#unwinding">Unwinding</a></h1>
<p>With the default panic handler (fittingly named “unwind”), when Rust code
calls <code>panic!()</code> Rust will begin walking local variables in the call stack to drop
them, then kill the thread. If the type is mutably shared across threads,
such as with a <code>Mutex&lt;T&gt;</code> does, then it may be in an inconsistent state,
though it should not be necessary to have a custom type doing that. However, What
is a concern is Rust calling drop on some types while they’re potentially in
inconsistent states. For example, say a <code>JavaRef&lt;T&gt;</code> type is used to represent a
reference held by Java. If it is busy updating its pointer for instance, and it
panics in that function, Rust’s unwinding will eventually call <code>drop()</code> on it, so
now the drop code is working with a <code>JavaRef&lt;T&gt;</code> with an invalid pointer.
Rust does have another panic handler called “abort” which just prints a stack
trace and aborts the process, which might be a better option if the types being used
are not believed to be unwind-safe.</p>
<h2 id="example-of-unwinding"><a class="header" href="#example-of-unwinding">Example of Unwinding</a></h2>
<p>Unwinding is implicit in Rust's error handling if a panic occurs. For explicit
handling:</p>
<pre><code class="language-rust ignore">match calculator.evaluate(tokens) {
    Ok(result) =&gt; println!("Result: {}", result),
    Err(e) =&gt; println!("Error: {}", e),
}</code></pre>
<p>To learn more about unwinding, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/unwinding.html">7</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phantom-data"><a class="header" href="#phantom-data">Phantom Data</a></h1>
<p>Sometimes, when working with unsafe code, there may be a situation where
<a href="lifetimes.html">lifetimes</a> are associated with a struct, but not part of a field. For example:</p>
<pre><code class="language-rust ignore">struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
}</code></pre>
<p>‘a isn’t being used in the body of this struct, so it’s unbounded. In Rust,
making these types of lifetime annotations for structs is not allowed because
of the implications it would have with maintaining correct variance and drop
checking. The solution Rust offers is <code>PhantomData</code>, which is a special marker
type. It doesn’t take up more memory, but it simulates a field of the desired struct
type to implement for static analysis. It is easy to implement, the
resulting struct would be:</p>
<pre><code class="language-rust ignore">struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,
}</code></pre>
<p>This way, the lifetime will be bounded to a “field” of the struct <code>Iter</code>. This may
bring up complications when writing a tool that automatically generates
bindings to call code because of the way it is designed. As previously
explained, <a href="method_handle.html">method handles</a> must be written for the different types a
function may be working with, and the <a href="https://openjdk.org/jeps/454">FFM API</a>
may be incompatible or unable to accommodate for a case where
<code>PhantomData</code> is used.
Rust uses <a href="unwinding.html">unwinding</a> to handle panics (unexpected errors) by default.
In this code, any panic (e.g., an out-of-bounds error) would unwind the stack
safely, cleaning up as it goes. Rust allows opting out of unwinding with
<code>panic=abort</code> for faster binaries.</p>
<p>To learn more about phantom data, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/phantom-data.html">3.10</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync"><a class="header" href="#send-and-sync">Send and Sync</a></h1>
<ul>
<li>Send: the type can be moved between threads.</li>
<li>Sync: a type can be shared between threads (logically equivalent to <code>&amp;T</code>
being Send)</li>
</ul>
<p>By default, most types are Send and Sync. If a type is moved to another
thread, it is fine because it owns its data and therefore nothing else can
touch that data or cause thread safety issues. If a shared reference is moved to
another thread, that is fine because the mere existence of a
shared reference means the data can no longer mutate, so there’s nothing
needing synchronization between threads. If an exclusive reference is moved, again
it is fine because that exclusive reference is the only thing
allowed to look at or modify the underlying data, so there is no need to
synchronize anything. The only types that are not both Send and Sync are
types that cheat the aliasing and ownership rules like <code>UnsafeCell&lt;T&gt;</code> and
<code>Rc&lt;T&gt;</code>.</p>
<p>Luckily, Java actually allows for this to be enforced. <code>Arena.ofConfined()</code> gives us
a thread-local memory <a href="arenas.html">arena</a>, and if code tries to use a <a href="memory_segment.html"><code>MemorySegment</code></a>
allocated from this arena in another thread it will throw an exception. This is
an absolute life saver, as it allows for the use of <code>RefCell&lt;T&gt;</code>, which is neither
Send nor Sync, and which is useful for fixing many of the incongruities
between Java and Rust’s memory models.</p>
<h2 id="example-of-thread-safety-and-send-and-sync"><a class="header" href="#example-of-thread-safety-and-send-and-sync">Example of Thread Safety and Send and Sync</a></h2>
<pre><code class="language-rust ignore">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let calculator = Arc::new(Mutex::new(PostfixCalculator::new()));
    let calculator_clone = Arc::clone(&amp;calculator);
    let handle = thread::spawn(move || {
        let mut calc = calculator_clone.lock().unwrap();
        let tokens: Vec&lt;&amp;str&gt; = "3 4 +".split_whitespace().collect();
        calc.evaluate(tokens)
    });
    
    match handle.join().unwrap() {
        Ok(result) =&gt; println!("Result from thread: {}", result),
        Err(e) =&gt; println!("Error from thread: {}", e),
    }
}</code></pre>
<p>Thread Safety: The Arc and Mutex wrapping of <code>PostfixCalculator</code> ensures that
it can be safely shared and mutated across threads. Arc allows for shared
ownership across threads, while Mutex provides mutual exclusion,
preventing <a href="data_races.html">data races</a>.</p>
<p>To learn more about Send and Sync traits, it is recommended to read these official Rust
resources: <em>The Rust Programming Language</em> chapter
<a href="https://rust-book.cs.brown.edu/ch16-04-extensible-concurrency-sync-and-send.html">16.4</a>, and <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">8.2</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-races"><a class="header" href="#data-races">Data Races</a></h1>
<p>Data races occur when multiple threads try to access the same
<a href="memory_segment.html">memory segment</a>, trying to write to it, and they can cause undefined behavior. Safe
Rust guarantees that no data races will occur, and a big player for this is the
<a href="ownership.html">ownership</a> model. By definition, if a value can only have one owner
(can make changes), then it can only be written to by its single owner. However,
general race conditions are not prevented in Rust. They simply can’t be
prevented from a mathematical standpoint, due to the way the scheduler
works in different operating systems. This is something that is out of the
developer's'
control. This means that while a program may get deadlocked, or have
incorrect synchronization, a Rust program will still be safe.</p>
<p>To learn more about subtyping and variance, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/races.html">8.1</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomics"><a class="header" href="#atomics">Atomics</a></h1>
<p>Atomics are types that support operations in a thread-safe manner without
external synchronization. For example, consider wanting to use a counter,
<code>foo</code>, you want to use across different threads. It would not be safe to
increment the counter using <code>foo++</code>, because that could result in a race
condition: different threads trying to increment <code>foo</code> by one will cause
undefined behavior. Locking can be used to make sure one thread
increments the value of <code>foo</code> by one, and then the other one, but it has
severe performance costs. Let’s say at first, <code>foo = 0</code>. Then, after both
threads write to it, <code>foo = 2</code> should be true. The way atomics would handle
this is: both threads would check if the value of <code>foo</code> is 0, and if it is,
increment to 1, otherwise, reevaluate. This would ensure that, no matter the
order the operating system decides to call these operations, at the end, <code>foo</code>
will be 2. Rust makes it very easy to work with atomics, for <code>foo</code>, just
write:</p>
<p><code>let foo = Arc::new(AtomicUsize::new(0));</code></p>
<p>To learn more about atomics, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/atomics.html">8.3</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-and-hardware-reordering"><a class="header" href="#compiler-and-hardware-reordering">Compiler and Hardware Reordering</a></h1>
<h2 id="compiler-reordering"><a class="header" href="#compiler-reordering">Compiler Reordering</a></h2>
<p>Rust’s compiler makes many optimizations to reduce the number of
operations the CPU will actually have to process. Sometimes it may as well
just remove operations. For example:</p>
<pre><code class="language-rust ignore">let x: i32 = 1;
x = 2;
x = 3;</code></pre>
<p>The compiler would remove the second line, <code>x = 2</code>, because it does not
change the result. The code will still define <code>x</code>, initialize it as an i32 variable
with value 1, and end with x having the value 3. However, if the result is not
used, the compiler is likely to completely remove all mentions of x. Why
bother generating code and allocating stack space for a value nobody will
notice is missing?</p>
<p>Rust uses the LLVM compiler infrastructure as its backend, the same thing
that the clang C compiler and clang++ C++ compiler use to generate
machine code. LLVM is very smart, and will do things such as delete dead
code, reorder operations to better saturate out-of-order CPUs, merge
redundant operations (<code>x += 1; x += 1</code> will be transformed to <code>x += 2</code>), keep
things in registers rather than ever touching memory, turn loops of normal
arithmetic into loops using SIMD/vector instructions. The point is, it is not clear
what the code is actually going to look like. The only thing that is guranteed is
that the compiler isn’t allowed to reorder things like print statements around each
other, or move <code>x += 1</code> to after a function call that uses <code>x</code>.</p>
<p>However, if there is access to another thread, these changes can be observed (with raw
pointers at least, Rust won’t normally let you do this sort of thing without
synchronization for a reason). So when multithreading, the developer must be explicit
to the compiler: “I want all writes performed before this point to be visible
before this operation, so other threads see what I want them to see”. That’s
where <a href="atomics.html">atomics</a> come into play.</p>
<h2 id="hardware-reordering"><a class="header" href="#hardware-reordering">Hardware Reordering</a></h2>
<p>Despite compiler reordering, depending on the hardware
architecture, some operations may be done in a different order by the CPU. This may
be the case due to how memory is accessed internally. Global memory can be
accessible everywhere but is slow, and cache memory is localized and faster.
Programs may have different threads running at the same time. Rust
guarantees that in each thread, the ordering will be correct. Despite that,
having different memory access speeds means that if two threads are
accessing memories that are vastly different in retrieval speed, the order in
which those threads run operations may be in the wrong order relative to
each other. If you now take a wrapper
class into consideration, ordering might be
thrown off even more. In these cases, Rust and Java’s atomic design
will put more strain on hardware by stalling some threads so that order guarantees
are kept.</p>
<p>To learn more about reordering, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/atomics.html">8.3</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-accesses"><a class="header" href="#data-accesses">Data Accesses</a></h1>
<p>Another way the <a href="./atomics.html">atomicity model</a> Rust employs deals with providing
strong guarantees is by introducing the concept of causality and providing tools to
establish relationships between different parts of a program and the threads
executing them. One of these, and potentially the most important, is the “happens
before” relationship. It defines the order of a program: if there is a statement
1 and statement 2, and there is a relationship of “statement 1 happens
before statement 2”, then statement 1 will be run before statement 2. This
provides extra information to the compiler and hardware about the ordering
of the operations, and allows for bigger optimizations on
operations that are not affected by the order they are executed in. Data accesses are
unsynchronized, which allows compilers to move them around as much as
they want to optimize performance, especially if the program is
single-threaded. The downside is that it can cause <a href="./data_races.html">data races</a>,
which results in undefined behavior. Atomic accesses tell the compiler and hardware
that the program is multi-threaded. They are marked with an ordering, which
limits how the <a href="./reordering.html">compiler and hardware can reorder</a> these statements.
In Rust,there are four types of <a href="./orderings.html">orderings</a>: sequentially consistent,
release, acquire,
relaxed.</p>
<p>To learn more about data accesses, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/atomics.html">8.3</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orderings"><a class="header" href="#orderings">Orderings</a></h1>
<h2 id="sequentially-consistent"><a class="header" href="#sequentially-consistent">Sequentially Consistent</a></h2>
<p>As its name suggests, operations that are sequentially consistent will be
executed sequentially. In other words, it guarantees that the execution of a
program with multiple threads behaves as if each thread’s operations
occurred in a certain order, without any <a href="./reordering.html">reordering</a> or
interleaving. This
means that if thread A is supposed to write to value x before thread B writes
to value x, B will only be able to write to value x once A has written to it. It
is implemented by using memory barriers: they are protecting x from B, and
they are only letting their guards down once A has written to it. Compiler and
hardware reordering makes a big difference in performance, so by restricting
the program in these fields, performance tends to suffer.</p>
<h2 id="acquire-and-release"><a class="header" href="#acquire-and-release">Acquire and Release</a></h2>
<p>Acquire and release work closely together, and they do so by acquiring locks
and releasing locks. This is similar to how locks are used in real life to
shut a door. On the outside anything can happen, but once a room is entered through a
door, the space there is completely separated from the
outside. In ordering, this means that any operations that are written after a
lock is acquired can not be reordered, and the whole block of code will be
executed sequentially in relation to the “outside world”. Once the block of
code is executed and the lock is released, all operations that come after that
are free to be reordered.</p>
<h2 id="relaxed"><a class="header" href="#relaxed">Relaxed</a></h2>
<p>Relaxed <a href="./data_accesses.html">data accesses</a> can be reordered freely, and doesn’t
provide the
“happens before” relationship. Despite that, they are still <a href="./atomics.html">atomic</a>,
and they
are used when a section needs to be executed without its order really
mattering. For example, using <code>fetch_add()</code> is a safe way of writing to a
counter (incrementing its value), assuming the counter isn’t used to
determine other accesses.</p>
<p>To learn more about orderings, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/atomics.html">8.3</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uninitialized-memory"><a class="header" href="#uninitialized-memory">Uninitialized Memory</a></h1>
<p>Rust allows developers to work with uninitialized memory. All memory that is
allocated during runtime is uninitialized at first, and it will contain garbage
values. Any novice programmer will know
that working with this memory will cause undefined behavior. Regardless,
Rust provides ways of working with uninitialized memory in safe and unsafe
ways.</p>
<h2 id="checked"><a class="header" href="#checked">Checked</a></h2>
<p>Rust by default doesn’t allow access to a <a href="memory_segment.html">memory segment</a> that has not
been initialized yet.
This is great for Java-Rust bindings because it ensures that even if an
attempt is made to access
uninitialized memory from the Java side (which would normally be allowed
and would produce undefined behavior) that is being allocated with Rust
through the <a href="https://openjdk.org/jeps/454">FFM API</a>, it won’t produce undefined
behavior or retrieve garbage values.</p>
<h2 id="drop-flags"><a class="header" href="#drop-flags">Drop Flags</a></h2>
<p>This is related to the concept of <a href="lifetimes.html">lifetimes</a>. Whenever a variable goes out of
scope, suppose a variable named <code>x</code> defined as <code>let mut x = Box::new(0);</code>, Rust
assigns the drop
flag, which then pushes the drop function, <code>drop(x)</code>, on the stack.
The concept of <a href="ownership.html">ownership</a> applies here too, where there can be only one pointer to a
memory segment.
Drop flags are tracked on the stack, and Rust decides when to drop a
value during runtime. This is relevant to creating bindings, because even though
Rust may have dropped a value, the Java variable that points to it when
using the FFM API
usually would not know that
happened. Having access to a drop flag allows for tracking when such
behavior happens, so they can be invalidated from the Java side too.</p>
<h2 id="unchecked"><a class="header" href="#unchecked">Unchecked</a></h2>
<p>Arrays can not be partially initialized, since null does not exist in Rust, so arrays that are defined
have to be fully initialized, with a value to every
section of memory that is represented by the indexes. This can make
developing code harder, especially when trying to work with dynamically
allocated arrays. To solve this, Rust implements the <code>MaybeUninit</code> type.
For example, to define an array that may be uninitialized, we would write:</p>
<pre><code class="language-rust ignore">let mut x: [MaybeUninit&lt;Box&lt;u32&gt;&gt;; SIZE] = unsafe {
    MaybeUninit::uninit().assume_init() };
}</code></pre>
<p>This works because the <code>MaybeUninit</code> is the only type that can be partially
initialized, and <code>.assume_init()</code> makes the Rust compiler think that the array
of <code>MaybeUninit&lt;T&gt;</code> was fully initialized. In this case, we are pointing to a
<code>Box</code>, which is a container for the type <code>u32</code>. The array can then be initialized
with the following:</p>
<pre><code class="language-rust ignore">for i in 0..SIZE {
    x[i] = MaybeUninit::new(Box::new(i as u32));
}</code></pre>
<p>Usually, when working with an array of pointers, assigning a new value to
<code>x[i]</code> would mean that the left hand side value would be dropped. But this is not
a problem when the left hand side contains <code>MaybeUninit&lt;Box&lt;u32&gt;&gt;</code>
because it does not contain anything, it just works as a placeholder. Finally,
that array that may be uninitialized may be turned into an array that we know
has been uninitialized with this line of code:<br />
<code>unsafe { mem::transmute::&lt;_, [Box&lt;u32&gt;; SIZE]&gt;(x) }</code></p>
<p>To learn more about checked uninitialized memory, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/checked-uninit.html">5.1</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
