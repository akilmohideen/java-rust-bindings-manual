<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java Bindings for Rust: A Comprehensive Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cha01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="cha02-00-basic_rust-to-java_bindings.html"><strong aria-hidden="true">2.</strong> Basic Rust-to-Java Bindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha02-01-writing_rust_functions_for_java.html"><strong aria-hidden="true">2.1.</strong> Writing Rust Functions for Java</a></li><li class="chapter-item expanded "><a href="cha02-02-compiling_rust_code_to_a_shared_library.html"><strong aria-hidden="true">2.2.</strong> Compiling Rust Code to a Shared Library</a></li><li class="chapter-item expanded "><a href="cha02-03-loading_the_shared_library_in_java.html"><strong aria-hidden="true">2.3.</strong> Loading the Shared Library in Java</a></li><li class="chapter-item expanded "><a href="cha02-04-understanding_java_imports.html"><strong aria-hidden="true">2.4.</strong> Understanding Java Imports</a></li></ol></li><li class="chapter-item expanded "><a href="cha03-00-handling_lifetimes_and_complex_data_structures.html"><strong aria-hidden="true">3.</strong> Handling Lifetimes and Complex Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha03-01-rust_functions_with_lifetimes.html"><strong aria-hidden="true">3.1.</strong> Rust Functions with Lifetimes</a></li><li class="chapter-item expanded "><a href="cha03-02-memory_management_in_java.html"><strong aria-hidden="true">3.2.</strong> Memory Management in Java</a></li></ol></li><li class="chapter-item expanded "><a href="cha04-00-advanced_scenarios.html"><strong aria-hidden="true">4.</strong> Advanced Scenarios</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha04-01-handling_rust_enums.html"><strong aria-hidden="true">4.1.</strong> Handling Rust Enums</a></li><li class="chapter-item expanded "><a href="cha04-02-passing_complex_data_structures.html"><strong aria-hidden="true">4.2.</strong> Passing Complex Data Structures</a></li><li class="chapter-item expanded "><a href="cha04-03-using_rust_traits_with_java.html"><strong aria-hidden="true">4.3.</strong> Using Rust Traits with Java</a></li><li class="chapter-item expanded "><a href="cha04-04-handling_rust_closures_and_higher-order_functions.html"><strong aria-hidden="true">4.4.</strong> Handling Rust Closures and Higher-Order Functions</a></li><li class="chapter-item expanded "><a href="cha04-05-async_rust_functions_in_java.html"><strong aria-hidden="true">4.5.</strong> Async Rust Functions in Java</a></li><li class="chapter-item expanded "><a href="cha04-06-error_handling_and_result_types.html"><strong aria-hidden="true">4.6.</strong> Error Handling and Result Types</a></li><li class="chapter-item expanded "><a href="cha04-07-safe_handling_of_unsafe_rust_code.html"><strong aria-hidden="true">4.7.</strong> Safe Handling of unsafe Rust Code</a></li><li class="chapter-item expanded "><a href="cha04-08-managing_multi-threaded_rust_applications.html"><strong aria-hidden="true">4.8.</strong> Managing Multi-threaded Rust Applications</a></li><li class="chapter-item expanded "><a href="cha04-09-custom_memory_allocators.html"><strong aria-hidden="true">4.9.</strong> Custom Memory Allocators</a></li><li class="chapter-item expanded "><a href="cha04-10-handling_global_state_in_rust.html"><strong aria-hidden="true">4.10.</strong> Handling Global State in Rust</a></li><li class="chapter-item expanded "><a href="cha04-11-integration_with_no_std_Rust.html"><strong aria-hidden="true">4.11.</strong> Integration with no_std Rust</a></li></ol></li><li class="chapter-item expanded "><a href="cha05-00-testing_and_debugging.html"><strong aria-hidden="true">5.</strong> Testing and Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha05-01-compile_and_run.html"><strong aria-hidden="true">5.1.</strong> Compile and Run</a></li><li class="chapter-item expanded "><a href="cha05-02-debugging.html"><strong aria-hidden="true">5.2.</strong> Debugging</a></li></ol></li><li class="chapter-item expanded "><a href="cha06-00-conclusion.html"><strong aria-hidden="true">6.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Bindings for Rust: A Comprehensive Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Java and Rust serve different purposes and have different strengths. Java is known for its portability and extensive ecosystem, while Rust is prized for its memory safety and performance. By creating bindings between these two languages, you can leverage Rust’s performance and safety in Java applications.</p>
<p>This manual will guide you through the process of creating these bindings, covering the most common and some advanced scenarios you might encounter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-rust-to-java-bindings"><a class="header" href="#basic-rust-to-java-bindings">Basic Rust-to-Java Bindings</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="writing-rust-functions-for-java"><a class="header" href="#writing-rust-functions-for-java">Writing Rust Functions for Java</a></h2>
<p>To expose Rust functions to Java, the functions need to be marked with <code>#[no_mangle]</code> and use the <code>extern "C"</code> calling convention. This prevents Rust from altering the function names and makes them accessible from other languages like Java.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern "C" fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="compiling-rust-code-to-a-shared-library"><a class="header" href="#compiling-rust-code-to-a-shared-library">Compiling Rust Code to a Shared Library</a></h2>
<p>To use Rust functions in Java, you need to compile the Rust code into a shared library. Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]
</code></pre>
<p>Compile the Rust code using:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>This will generate a shared library (e.g., .so on Linux, <code>.dll</code> on Windows, <code>.dylib</code> on macOS) in the <code>target/release/</code> directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="loading-the-shared-library-in-java"><a class="header" href="#loading-the-shared-library-in-java">Loading the Shared Library in Java</a></h2>
<p>In Java, use SymbolLookup and Linker to load the shared library and access the Rust functions.</p>
<pre><code class="language-java">import java.lang.foreign.ValueLayout;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.Linker;
import java.lang.invoke.MethodHandle;
import java.lang.foreign.Arena;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.MemorySegment;

public class RustBindings {
    static {
        SymbolLookup lib = SymbolLookup.libraryLookup("librustlib.so", Arena.global());
        Linker linker = Linker.nativeLinker();

        MethodHandle addHandle = linker.downcallHandle(
            lib.find("add").orElseThrow(),
            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT)
        );
    }

    public static void main(String[] args) throws Throwable {
        // Example usage
        int result = (int) addHandle.invokeExact(3, 4);
        System.out.println("Result: " + result);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="understanding-java-imports"><a class="header" href="#understanding-java-imports">Understanding Java Imports</a></h2>
<p>When working with Rust-Java bindings, certain Java imports are essential. Here's a breakdown of the key imports and their purposes:</p>
<ul>
<li>
<h3 id="import-javalangforeignvaluelayout"><a class="header" href="#import-javalangforeignvaluelayout">import java.lang.foreign.ValueLayout;</a></h3>
</li>
</ul>
<p><strong>Purpose:</strong> ValueLayout defines memory layouts for various data types such as <code>JAVA_INT</code>, <code>JAVA_DOUBLE</code>, and <code>JAVA_LONG</code>. These layouts describe how data is structured in memory and are used in function descriptors to ensure Java and Rust understand the data's structure.</p>
<p><strong>Usage Example:</strong> <code>FunctionDescriptor.of</code>(<code>ValueLayout.JAVA_INT</code>, <code>ValueLayout.JAVA_INT</code>, <code>ValueLayout.JAVA_INT</code>) defines a function signature that takes two integers and returns an integer.</p>
<ul>
<li>
<h3 id="import-javalanginvokemethodhandle"><a class="header" href="#import-javalanginvokemethodhandle">import java.lang.invoke.MethodHandle;</a></h3>
</li>
</ul>
<p><strong>Purpose:</strong> <code>MethodHandle</code> represents a reference to a method, which can be dynamically invoked. In this context, it is used to call Rust functions from Java after linking them using <code>downcallHandle</code>.</p>
<p><strong>Usage Example:</strong> <code>MethodHandle addHandle = linker.downcallHandle(...);</code> allows invoking the add function from Rust in Java.</p>
<ul>
<li>
<h3 id="import-javalangforeignsymbollookup"><a class="header" href="#import-javalangforeignsymbollookup">import java.lang.foreign.SymbolLookup;</a></h3>
</li>
</ul>
<p><strong>Purpose:</strong> <code>SymbolLookup</code> is used to find symbols (e.g., function names, static variables) within the Rust shared library. It is essential for dynamically loading the library's functions into Java.</p>
<p><strong>Usage Example:</strong> Usage Example: <code>SymbolLookup lib = SymbolLookup.libraryLookup("librustlib.so", Arena.global());</code> loads the Rust shared library into the Java runtime.</p>
<ul>
<li>
<h3 id="import-javalangforeignlinker"><a class="header" href="#import-javalangforeignlinker">import java.lang.foreign.Linker;</a></h3>
</li>
</ul>
<p><strong>Purpose:</strong> Linker is responsible for linking Java code with native code (in this case, Rust). It provides methods like <code>downcallHandle</code> to create MethodHandle instances for calling native functions from Java.</p>
<p><strong>Usage Example:</strong> <code>Linker linker = Linker.nativeLinker();</code> initializes a linker to facilitate the interaction between Java and Rust.</p>
<ul>
<li>
<h3 id="import-javalangforeignarena"><a class="header" href="#import-javalangforeignarena">import java.lang.foreign.Arena;</a></h3>
</li>
</ul>
<p><strong>Purpose:</strong> <code>Arena</code> manages memory allocation in Java for interacting with native code. It provides methods to allocate memory that Java code can control and free automatically when the <code>MemorySegment</code> is garbage collected.</p>
<p><strong>Usage Example:</strong> <code>Arena arena = Arena.ofConfined();</code> creates a memory arena that ensures memory is confined to the scope of the operation, preventing memory leaks.</p>
<ul>
<li>
<h3 id="import-javalangforeignfunctiondescriptor"><a class="header" href="#import-javalangforeignfunctiondescriptor">import java.lang.foreign.FunctionDescriptor;</a></h3>
</li>
</ul>
<p><strong>Purpose:</strong> <code>FunctionDescriptor</code> describes the signature of a native function, including its return type and parameter types. This is necessary for correctly linking Java methods to the corresponding Rust functions.</p>
<p><strong>Usage Example:</strong> <code>FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT)</code> describes a function that returns an integer and takes two integers as arguments.</p>
<ul>
<li>
<h3 id="import-javalangforeignmemorysegment"><a class="header" href="#import-javalangforeignmemorysegment">import java.lang.foreign.MemorySegment;</a></h3>
</li>
</ul>
<p><strong>Purpose:</strong> <code>MemorySegment</code> represents a contiguous region of memory. It’s used to manage memory that is passed between Java and Rust, ensuring the correct handling of memory regions allocated for Rust structs or arrays.</p>
<p><strong>Usage Example:</strong> <code>MemorySegment mem = arena.allocate(ValueLayout.JAVA_INT);</code> allocates memory for an integer, which can then be passed to Rust.</p>
<p>These imports collectively enable Java to interact with Rust, managing memory, linking functions, and ensuring data structures are correctly interpreted across the two languages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-lifetimes-and-complex-data-structures"><a class="header" href="#handling-lifetimes-and-complex-data-structures">Handling Lifetimes and Complex Data Structures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust-functions-with-lifetimes"><a class="header" href="#rust-functions-with-lifetimes">Rust Functions with Lifetimes</a></h2>
<p>Lifetimes ensure that references in Rust are valid as long as they are needed. When exposing such functions to Java, care must be taken to ensure that the references remain valid and are not prematurely deallocated by Java’s garbage collector (GC).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    ptr: Option&lt;&amp;'a i32&gt;,
    number: i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    #[no_mangle]
    extern "C" fn new() -&gt; Box&lt;Self&gt; {
        Box::new(Foo { ptr: None, number: 42 })
    }

    #[no_mangle]
    extern "C" fn update(&amp;'a mut self, ptr: &amp;'a i32) {
        self.ptr = Some(ptr);
    }

    #[no_mangle]
    extern "C" fn get(&amp;self) -&gt; i32 {
        *self.ptr.unwrap_or(&amp;-1)
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="memory-management-in-java"><a class="header" href="#memory-management-in-java">Memory Management in Java</a></h2>
<p>In Java, you need to manage memory explicitly when dealing with Rust structures that include lifetimes or references. Use <code>Arena.ofConfined()</code> to allocate memory that is tied to the scope of an operation, ensuring that it is freed when no longer needed.</p>
<p>Example:</p>
<pre><code class="language-java">try (Arena arena = Arena.ofConfined()) {
    MemorySegment mem = arena.allocate(ValueLayout.JAVA_INT);
    mem.set(ValueLayout.JAVA_INT, 0, 42);
    
    MethodHandle fooUpdate = Global.linker.downcallHandle(
        Global.lib.find("foo_update").orElseThrow(),
        FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, ValueLayout.ADDRESS)
    );
    
    fooUpdate.invokeExact(foo, mem);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-scenarios"><a class="header" href="#advanced-scenarios">Advanced Scenarios</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="handling-rust-enums"><a class="header" href="#handling-rust-enums">Handling Rust Enums</a></h2>
<p>Rust enums can be challenging to map to Java, as Java does not have a direct equivalent. You can represent Rust enums using Java classes or tagged unions.</p>
<p>Example Rust enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    Success,
    Error(i32),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="passing-complex-data-structures"><a class="header" href="#passing-complex-data-structures">Passing Complex Data Structures</a></h2>
<p>Complex Rust structs with nested fields or references need to be carefully mapped and managed in Java. Ensure that memory for such structs is correctly allocated and freed, and that data integrity is maintained.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ComplexStruct {
    id: i32,
    name: String,
    data: Vec&lt;u8&gt;,
}

#[no_mangle]
extern "C" fn new_complex_struct() -&gt; Box&lt;ComplexStruct&gt; {
    Box::new(ComplexStruct {
        id: 1,
        name: String::from("Example"),
        data: vec![1, 2, 3, 4],
    })
}
<span class="boring">}</span></code></pre></pre>
<p>In Java:</p>
<pre><code class="language-java">try (Arena arena = Arena.ofConfined()) {
    MemorySegment structSegment = arena.allocate(Global.complexStructSize, Global.complexStructAlign);
    MethodHandle newComplexStruct = Global.linker.downcallHandle(
        Global.lib.find("new_complex_struct").orElseThrow(),
        FunctionDescriptor.of(ValueLayout.ADDRESS)
    );

    MemorySegment complexStruct = (MemorySegment) newComplexStruct.invokeExact();
    // Use the complexStruct...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-rust-traits-with-java"><a class="header" href="#using-rust-traits-with-java">Using Rust Traits with Java</a></h2>
<p>Traits in Rust provide polymorphism. When mapping these to Java, consider using Java interfaces or abstract classes to represent Rust traits.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Greet {
    fn greet(&amp;self) -&gt; String;
}

struct Person {
    name: String,
}

impl Greet for Person {
    fn greet(&amp;self) -&gt; String {
        format!("Hello, {}!", self.name)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In Java, you might create an interface that the Rust implementation can fulfill:</p>
<pre><code class="language-java">public interface Greet {
    String greet();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="handling-rust-closures-and-higher-order-functions"><a class="header" href="#handling-rust-closures-and-higher-order-functions">Handling Rust Closures and Higher-Order Functions</a></h2>
<p>Rust closures are not directly compatible with Java’s FFI. You may need to wrap them in Rust before exposing them to Java or convert them to Java lambdas or <code>MethodHandles</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern "C" fn apply_closure(x: i32, f: extern "C" fn(i32) -&gt; i32) -&gt; i32 {
    f(x)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="async-rust-functions-in-java"><a class="header" href="#async-rust-functions-in-java">Async Rust Functions in Java</a></h2>
<p>Rust’s <code>async</code> functions must be carefully integrated with Java’s concurrency model. Consider using Java’s <code>CompletableFuture</code> to represent Rust’s <code>Future</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

#[no_mangle]
extern "C" fn async_add(a: i32, b: i32) -&gt; impl Future&lt;Output = i32&gt; {
    async move { a + b }
}


In Java, you would create a CompletableFuture to handle the result of the async operation:

CompletableFuture&lt;Integer&gt; result = CompletableFuture.supplyAsync(() -&gt; {
    return (int) asyncAddHandle.invokeExact(3, 4);
});
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="error-handling-and-result-types"><a class="header" href="#error-handling-and-result-types">Error Handling and Result Types</a></h2>
<p>Rust’s <code>Result&lt;T, E&gt;</code> types map naturally to Java’s exception handling. You can translate Rust errors into Java exceptions or use Java’s <code>Optional</code> for <code>Option</code> types.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern "C" fn divide(a: i32, b: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {
    if b == 0 {
        Err("division by zero")
    } else {
        Ok(a / b)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In Java:</p>
<pre><code class="language-java">try {
    int result = (int) divideHandle.invokeExact(10, 2);
} catch (Throwable e) {
    System.out.println("Error: " + e.getMessage());
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="safe-handling-of-unsafe-rust-code"><a class="header" href="#safe-handling-of-unsafe-rust-code">Safe Handling of unsafe Rust Code</a></h2>
<p>When exposing <code>unsafe</code> Rust code to Java, wrap it in a safe Rust API. This ensures that Java code cannot inadvertently cause undefined behavior.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
unsafe extern "C" fn dangerous_operation(ptr: *mut i32) {
    if !ptr.is_null() {
        *ptr += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="managing-multi-threaded-rust-applications"><a class="header" href="#managing-multi-threaded-rust-applications">Managing Multi-threaded Rust Applications</a></h2>
<p>When using multi-threaded Rust code with Java, ensure that data races are avoided and that synchronization is handled properly.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

struct SharedData {
    counter: Mutex&lt;i32&gt;,
}

#[no_mangle]
extern "C" fn increment(shared_data: &amp;SharedData) {
    let mut counter = shared_data.counter.lock().unwrap();
    *counter += 1;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="custom-memory-allocators"><a class="header" href="#custom-memory-allocators">Custom Memory Allocators</a></h2>
<p>When using custom memory allocators in Rust, ensure that memory is managed consistently when passed to Java. Mismanagement can lead to memory leaks or corruption.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="handling-global-state-in-rust"><a class="header" href="#handling-global-state-in-rust">Handling Global State in Rust</a></h2>
<p>Global state in Rust must be managed carefully when exposed to Java, particularly in multi-threaded environments.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static GLOBAL_COUNTER: AtomicUsize = AtomicUsize::new(0);

#[no_mangle]
extern "C" fn increment_global() {
    GLOBAL_COUNTER.fetch_add(1, Ordering::SeqCst);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="integration-with-no_std-rust"><a class="header" href="#integration-with-no_std-rust">Integration with <code>no_std</code> Rust</a></h2>
<p>If your Rust code does not use the standard library (<code>no_std</code>), special considerations are required when interfacing with Java. Ensure that memory and I/O are handled without relying on standard library features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-and-debugging"><a class="header" href="#testing-and-debugging">Testing and Debugging</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="compile-and-run"><a class="header" href="#compile-and-run">Compile and Run</a></h2>
<p>Ensure that the Rust library is correctly compiled and the Java code compiles without errors. Test the integration by running the Java application and verifying that it interacts with the Rust library as expected.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<p>When debugging, pay special attention to:</p>
<ul>
<li><strong>Memory management:</strong> Ensure that memory is correctly allocated and freed.</li>
<li><strong>Function signatures:</strong> Verify that the Rust function signatures match those expected by Java.</li>
<li><strong>Data integrity:</strong> Ensure that data passed between Rust and Java is correctly handled, especially when dealing with complex structures or lifetimes.</li>
<li><strong>Synchronization:</strong> In multi-threaded applications, ensure that data races and deadlocks are avoided.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>By following this manual, you can create robust and efficient Java bindings for Rust libraries. The guide covers a wide range of scenarios, from simple function calls to complex memory management and multi-threaded applications. Properly handling these cases ensures that your Java applications can safely and effectively leverage Rust’s capabilities.</p>
<p>As you develop more complex Rust libraries, refer back to this manual to guide you in creating comprehensive and safe bindings that integrate seamlessly with Java.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
