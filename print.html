<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java Bindings for Rust: A Comprehensive Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Java Bindings for Rust: A Comprehensive Guide</a></li><li class="chapter-item expanded "><a href="cha01-00.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha01-01.html"><strong aria-hidden="true">1.1.</strong> Purpose of the Manual</a></li><li class="chapter-item expanded "><a href="cha01-02.html"><strong aria-hidden="true">1.2.</strong> Why Java 22?</a></li><li class="chapter-item expanded "><a href="cha01-03.html"><strong aria-hidden="true">1.3.</strong> How Java and Rust Work Together</a></li><li class="chapter-item expanded "><a href="cha01-04.html"><strong aria-hidden="true">1.4.</strong> What This Manual Hopes to Accomplish</a></li></ol></li><li class="chapter-item expanded "><a href="cha02-00.html"><strong aria-hidden="true">2.</strong> Setting Up and Linking Rust and Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha02-01.html"><strong aria-hidden="true">2.1.</strong> How Rust and Java Communicate</a></li><li class="chapter-item expanded "><a href="cha02-02.html"><strong aria-hidden="true">2.2.</strong> Setting Up Rust</a></li><li class="chapter-item expanded "><a href="cha02-03.html"><strong aria-hidden="true">2.3.</strong> Setting Up Java</a></li></ol></li><li class="chapter-item expanded "><a href="cha03-00.html"><strong aria-hidden="true">3.</strong> Mapping Rust Features to Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cha03-01.html"><strong aria-hidden="true">3.1.</strong> Accounting for Rust Lifetimes</a></li><li class="chapter-item expanded "><a href="cha03-02.html"><strong aria-hidden="true">3.2.</strong> Handling Ownership and Borrowing</a></li><li class="chapter-item expanded "><a href="cha03-03.html"><strong aria-hidden="true">3.3.</strong> Memory Layouts and Structs</a></li><li class="chapter-item expanded "><a href="cha03-04.html"><strong aria-hidden="true">3.4.</strong> Handling Thread Safety in Rust</a></li><li class="chapter-item expanded "><a href="cha03-05.html"><strong aria-hidden="true">3.5.</strong> Handling Rust’s Enums and Option Types</a></li></ol></li><li class="chapter-item expanded "><a href="cha04-00.html"><strong aria-hidden="true">4.</strong> Handling Common Data Structures</a></li><li class="chapter-item expanded "><a href="cha05-00.html"><strong aria-hidden="true">5.</strong> Edge Cases and Troubleshooting</a></li><li class="chapter-item expanded "><a href="cha06-00.html"><strong aria-hidden="true">6.</strong> Comprehensive Example</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="value_layout.html"><strong aria-hidden="true">7.</strong> Value Layout</a></li><li class="chapter-item expanded "><a href="so.html"><strong aria-hidden="true">8.</strong> Shared Object and Dynamic Library Files</a></li><li class="chapter-item expanded "><a href="arenas.html"><strong aria-hidden="true">9.</strong> Arenas</a></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">10.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="borrowing_and_aliasing.html"><strong aria-hidden="true">11.</strong> Borrowing and Aliasing</a></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">12.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="subtyping_and_variance.html"><strong aria-hidden="true">13.</strong> Subtyping and Variance</a></li><li class="chapter-item expanded "><a href="unwinding.html"><strong aria-hidden="true">14.</strong> Unwinding</a></li><li class="chapter-item expanded "><a href="phantom_data.html"><strong aria-hidden="true">15.</strong> Phantom Data</a></li><li class="chapter-item expanded "><a href="send_and_sync.html"><strong aria-hidden="true">16.</strong> Send and Sync</a></li><li class="chapter-item expanded "><a href="data_races.html"><strong aria-hidden="true">17.</strong> Data Races</a></li><li class="chapter-item expanded "><a href="atomics.html"><strong aria-hidden="true">18.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="reordering.html"><strong aria-hidden="true">19.</strong> Compiler and Hardware Reordering</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Bindings for Rust: A Comprehensive Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="java-bindings-for-rust-a-comprehensive-guide"><a class="header" href="#java-bindings-for-rust-a-comprehensive-guide">Java Bindings for Rust: A Comprehensive Guide</a></h1>
<p><em>by Akil Mohideen, Natalya McKay, Santiago Martinez Sverko, and Seth Kaul</em>
<em>Sponsored by Ethan McCue</em></p>
<p>This document assumes you have <strong>Rust 1.81.0</strong> and <strong>Java 22</strong> or later. If you have not installed Rust or Java, you can install Rust <a href="https://www.rust-lang.org/tools/install">here</a> and Java <a href="https://www.oracle.com/java/technologies/downloads/">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <em><strong>Java Bindings for Rust: A Comprehensive Guide</strong></em>, a guide to using Rust from within Java. This process can be notoriously confusing, and the information on how to do it is dense and scattered across various sources. This guide teaches how to make these bindings in a digestible way. Every section was created to be as short and readable as possible without barring important information. Complex details will be kept in their own sections, and will be linked to when they are applicable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="purpose-of-the-manual"><a class="header" href="#purpose-of-the-manual">Purpose of the Manual</a></h1>
<p>The purpose of this manual is to provide a comprehensive guide for creating Java bindings to Rust libraries using <strong>Java 22</strong> and <strong>Rust 1.81.0</strong>. It will cover the essential steps and concepts required to allow Java applications to call Rust functions, making use of the <a href="https://openjdk.org/jeps/454">Foreign Function and Memory API</a>. By the end of this manual, developers will be able to seamlessly integrate Rust’s high-performance, memory-safe capabilities into their Java applications, enabling cross-language functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-java-22"><a class="header" href="#why-java-22">Why Java 22?</a></h1>
<p>Java 22 introduces the <a href="https://openjdk.org/jeps/454">Foreign Function and Memory API</a>, a modern alternative to the legacy <strong>Java Native Interface (JNI)</strong>. JNI was traditionally used to interact with C-like functions and data types in external libraries. However, JNI is cumbersome, error-prone, and introduces significant overhead due to repeated native function calls and lack of <strong>Just-In-Time (JIT)</strong> optimizations. Java objects needed to be passed through JNI, requiring additional work on the native side to identify object types and data locations, making the entire process tedious and slow.
With the Foreign Function and Memory API, Java now pushes much of the integration work to the Java side, eliminating the need for custom C headers and providing more visibility for the JIT compiler. This change leads to:</p>
<ul>
<li><strong>Better Performance</strong>: The JIT compiler can now optimize calls to native libraries more effectively.</li>
<li><strong>Simplified Integration</strong>: There are fewer requirements on native function signatures, reducing the overhead of native-to-Java translation.</li>
<li><strong>Enhanced Flexibility</strong>: The API supports working with various languages like Rust while maintaining full control over how memory and function calls are handled.</li>
</ul>
<p>Java 22 is the first version to stabilize this API, making it the ideal choice for this manual. It enables efficient, direct interaction with Rust libraries without the historical drawbacks of JNI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-java-and-rust-work-together"><a class="header" href="#how-java-and-rust-work-together">How Java and Rust Work Together</a></h1>
<p>How Java and Rust Work Together
Rust is a system-level language that provides fine-grained control over memory management, making it a popular choice for performance-critical applications. Java, on the other hand, excels in providing portability and high-level abstractions. By using the Foreign Function and Memory API in Java 22, developers can leverage Rust’s performance and memory safety in Java applications.
Key components of this integration include:</p>
<ul>
<li><strong>Java’s Foreign Function and Memory API</strong>: This API provides classes such as <code>SymbolLookup</code>, <code>FunctionDescriptor</code>, <code>Linker</code>, <code>MethodHandle</code>, <a href="arenas.html"><code>Arena</code></a>, and <code>MemorySegment</code>, which enable Java to call foreign functions and manage memory effectively.</li>
<li><strong>Rust’s Application Binary Interface (ABI)</strong>: Rust functions exposed to Java must adhere to the <strong>C ABI</strong>, ensuring compatibility between the two languages.</li>
<li><strong>Memory Management</strong>: The manual will explore how to allocate, manage, and release memory safely between Java and Rust, ensuring optimal performance and avoiding memory leaks or undefined behavior.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-this-manual-hopes-to-accomplish"><a class="header" href="#what-this-manual-hopes-to-accomplish">What This Manual Hopes to Accomplish</a></h1>
<p>This manual aims to:</p>
<ol>
<li><strong>Provide a Step-by-Step Guide</strong>: It will walk developers through setting up their environment, configuring Rust and Java projects, and linking the two using the Foreign Function and Memory API.</li>
<li><strong>Demonstrate Practical Examples</strong>: By the end of the manual, developers will have worked through real-world examples, including exposing Rust functions, handling complex data types, managing lifetimes and memory, and handling multi-threading.</li>
<li><strong>Simplify Rust-Java Integration</strong>: The manual will demystify the integration process, helping developers avoid common pitfalls related to ownership, memory management, and data layout discrepancies.</li>
<li><strong>Address Advanced Topics</strong>: In addition to the basics, the manual will explore advanced topics such as thread safety, handling Rust’s ownership and borrowing rules in Java, and how to handle complex data structures and edge cases.</li>
</ol>
<p>By following this guide, developers will gain a deep understanding of how to efficiently and safely call Rust libraries from Java, making full use of both Java 22’s Foreign Function and Memory API and Rust’s robust performance and memory safety features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-and-linking-rust-and-java"><a class="header" href="#setting-up-and-linking-rust-and-java">Setting Up and Linking Rust and Java</a></h1>
<p>In this section, we will explain how to set up and link the Rust and Java sides to create Java bindings for Rust libraries. This process involves configuring Rust to export functions in a way Java can access, and using Java's <strong>Foreign Function and Memory API</strong> to dynamically link to the Rust code. We'll also cover how to work with <strong>FunctionDescriptors</strong>, <strong>Arenas</strong>, <strong>MemoryLayouts</strong>, and other key components necessary to ensure safe and efficient communication between Java and Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-rust-and-java-communicate"><a class="header" href="#how-rust-and-java-communicate">How Rust and Java Communicate</a></h1>
<p>Java and Rust communicate through <strong>dynamic linking</strong>, where Rust compiles into a <a href="so.html">shared library</a> file (e.g., <code>.dll</code> on Windows, <code>.so</code> on Linux, <code>.dylib</code> on macOS). Java loads this library and can interact with its functions.
At a high level, the process looks like this:</p>
<ol>
<li><strong>Rust</strong>: You write Rust functions, export them with <code>#[no_mangle]</code> and extern <code>"C"</code>, and compile them into a shared library.</li>
<li><strong>Java</strong>: You use Java’s <strong>Foreign Function and Memory API</strong> to load the shared library, find the Rust functions, and invoke them.
Now, let’s go step by step through both the Rust and Java setups.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-rust"><a class="header" href="#setting-up-rust">Setting Up Rust</a></h1>
<h2 id="step-1-exporting-rust-functions"><a class="header" href="#step-1-exporting-rust-functions">Step 1: Exporting Rust Functions</a></h2>
<p>To make Rust functions callable from Java, we need to do two things:</p>
<ul>
<li>Use <code>#[no_mangle]</code> to prevent Rust from renaming (mangling) the function name. This ensures Java can find the function by its exact name.</li>
<li>Declare the function with <code>extern "C"</code> to make sure it uses the <strong>C Application Binary Interface (ABI)</strong>, which Java understands.</li>
</ul>
<h3 id="rust-example"><a class="header" href="#rust-example">Rust Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn create_point(x: i32, y: i32) -&gt; *mut Point {
    Box::into_raw(Box::new(Point { x, y }))
}

#[no_mangle]
pub extern "C" fn get_x(point: *mut Point) -&gt; i32 {
    unsafe { (*point).x }
}

#[no_mangle]
pub extern "C" fn free_point(point: *mut Point) {
    unsafe { Box::from_raw(point); } // Frees the allocated memory
}

struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation:</a></h3>
<ul>
<li><code>#[no_mangle]:</code> Prevents Rust from changing the function’s name during compilation. Without this, Java would not be able to call the function by its original name (create_point).</li>
<li><code>extern "C":</code> This tells Rust to use the <strong>C ABI</strong>, ensuring compatibility with Java’s native linking mechanism.</li>
<li><code>*mut Point:</code> The function returns a raw pointer (*mut Point), which Java can manage using the Foreign Function and Memory API.</li>
</ul>
<h2 id="step-2-compiling-rust-into-a-shared-library"><a class="header" href="#step-2-compiling-rust-into-a-shared-library">Step 2: Compiling Rust into a Shared Library</a></h2>
<p>To compile the Rust code into a format Java can load, modify the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]
</code></pre>
<p>Then, compile the Rust project into a shared library:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>This command will generate a shared library file (e.g., <code>libmyrustlib.so</code> or <code>myrustlib.dll</code>) in the <code>target/release/</code> directory, which Java can dynamically load.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-java"><a class="header" href="#setting-up-java">Setting Up Java</a></h1>
<p>Once the Rust library is compiled, Java can load the shared library and access the Rust functions.</p>
<h2 id="step-1-loading-the-rust-shared-library"><a class="header" href="#step-1-loading-the-rust-shared-library">Step 1: Loading the Rust Shared Library</a></h2>
<p>Java uses <strong><code>SymbolLookup</code></strong> to load the shared library and retrieve the addresses of the Rust functions. Java’s <strong><code>Linker</code></strong> allows us to bind those addresses to callable <code>MethodHandle</code> objects, which represent native functions in Java.
Here’s how to load the Rust library and link the <code>create_point</code> function:</p>
<h3 id="java-example"><a class="header" href="#java-example">Java Example</a></h3>
<pre><code class="language-java">import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;

public class RustBindings {
    static MethodHandle createPoint;
    static MethodHandle getX;
    static MethodHandle freePoint;

    static {
        var linker = Linker.nativeLinker(); // Initializes the native linker
        var lib = SymbolLookup.libraryLookup("libmyrustlib.so", Arena.global()); // Loads the Rust library

        // Link the Rust functions
        createPoint = linker.downcallHandle(
            lib.find("create_point").orElseThrow(), 
            FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT)
        );
        getX = linker.downcallHandle(
            lib.find("get_x").orElseThrow(), 
            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS)
        );
        freePoint = linker.downcallHandle(
            lib.find("free_point").orElseThrow(), 
            FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)
        );
    }
}
</code></pre>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation:</a></h3>
<ul>
<li><strong><code>libraryLookup</code></strong>: Loads the Rust shared library (<code>libmyrustlib.so</code>). The library must be available in the Java classpath or in the system’s library path.</li>
<li><strong><code>FunctionDescriptor</code></strong>: Defines the signature of the Rust function in Java terms. For example:
<ul>
<li><strong><code>ValueLayout.ADDRESS</code></strong>: Corresponds to a pointer (Rust’s <code>*mut</code>).</li>
<li><strong><code>ValueLayout.JAVA_INT</code></strong>: Corresponds to Rust’s <code>i32</code>.</li>
</ul>
</li>
<li>MethodHandle: Represents the linked Rust function. This is how Java will call the Rust function.</li>
</ul>
<h2 id="step-2-calling-rust-functions-from-java"><a class="header" href="#step-2-calling-rust-functions-from-java">Step 2: Calling Rust Functions from Java</a></h2>
<p>With the library loaded and the functions linked, we can now call the Rust functions from Java using <code>MethodHandle.invokeExact()</code>. Here’s how to create a point in Rust, get its <code>x</code> value, and free the memory:</p>
<h3 id="java-example-1"><a class="header" href="#java-example-1">Java Example</a></h3>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws Throwable {
        // Create a point in Rust
        MemorySegment point = (MemorySegment) RustBindings.createPoint.invokeExact(10, 20);

        // Get the x value from the point
        int xValue = (int) RustBindings.getX.invokeExact(point);
        System.out.println("X value: " + xValue);

        // Free the Rust point
        RustBindings.freePoint.invokeExact(point);
    }
}
</code></pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation:</a></h3>
<ul>
<li><strong><code>MemorySegment</code></strong>: This is Java’s way of handling memory passed to and from Rust. Here, it represents the raw pointer to the Rust Point structure.</li>
<li><strong><code>nvokeExact()</code></strong>: Calls the linked Rust function with the specified arguments. In this case:
<ul>
<li><code>RustBindings.createPoint.invokeExact(10, 20)</code> creates a <code>Point</code> in Rust with <code>x = 10</code> and <code>y = 20</code>.</li>
<li><code>RustBindings.getX.invokeExact(point)</code> retrieves the <code>x</code> value from the Rust point.</li>
<li><code>RustBindings.freePoint.invokeExact(point)</code> frees the memory in Rust.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapping-rust-features-to-java"><a class="header" href="#mapping-rust-features-to-java">Mapping Rust Features to Java</a></h1>
<p>In this section, we will cover how to map key Rust features to their Java equivalents. For each Rust concept, we'll go through:</p>
<ol>
<li>How to Identify the feature in Rust.</li>
<li>What to do in Java to handle it properly.
By the end of this section, you'll be able to look at a Rust function and determine what needs to be written in Java to bind it correctly. This includes handling lifetimes, ownership, memory layouts, thread safety, and more.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accounting-for-rust-lifetimes"><a class="header" href="#accounting-for-rust-lifetimes">Accounting for Rust Lifetimes</a></h1>
<h2 id="identifying-lifetimes-in-rust"><a class="header" href="#identifying-lifetimes-in-rust">Identifying Lifetimes in Rust</a></h2>
<p>In Rust, <strong>lifetimes</strong> are used to manage how long references (<code>&amp;</code>, <code>&amp;mut</code>) are valid. Lifetimes ensure that references to data don’t outlive the data they point to, preventing dangling pointers. Lifetimes are commonly seen in function signatures or struct definitions as <code>&lt;'a&gt;</code> annotations.</p>
<h3 id="example"><a class="header" href="#example">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn borrow&lt;'a&gt;(input: &amp;'a i32) -&gt; &amp;'a i32 {
    input
}
<span class="boring">}</span></code></pre></pre>
<p>In the above example, <code>input</code> has a lifetime <code>'a</code>, and the return type shares the same lifetime. This means the reference returned by the function cannot outlive the reference passed to it.</p>
<h2 id="handling-lifetimes-in-java"><a class="header" href="#handling-lifetimes-in-java">Handling Lifetimes in Java</a></h2>
<p>Java does not have explicit lifetimes, so we need to simulate Rust’s lifetime behavior using <strong>memory management techniques</strong>. Specifically, when dealing with temporary references in Rust, you can manage the memory in Java using <a href="arenas.html">Arenas</a>.</p>
<h3 id="what-you-need-to-do"><a class="header" href="#what-you-need-to-do">What You Need to Do:</a></h3>
<ul>
<li><strong>For short-lived references</strong>: Use <strong>Confined Arenas</strong> in Java, ensuring the memory is released once the function is done.</li>
<li><strong>For long-lived references</strong>: Use <strong>Global Arenas</strong> if the reference needs to persist across multiple calls.</li>
</ul>
<h3 id="java-example-handling-lifetimes"><a class="header" href="#java-example-handling-lifetimes">Java Example (Handling Lifetimes):</a></h3>
<pre><code class="language-java">// Create a confined arena for a short-lived Rust reference
var arena = Arena.ofConfined();
MemorySegment borrowedSegment = arena.allocate(8);  // Allocate 8 bytes for a reference

// Call the Rust function, passing in the borrowed reference
RustBindings.borrow.invokeExact(borrowedSegment);

// When the arena is closed, the memory is freed
arena.close();  // Ensures the borrowed reference is no longer accessible
</code></pre>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation:</a></h3>
<ul>
<li><strong>Confined Arenas</strong> are used here to manage temporary references, ensuring that the memory is properly cleaned up after the Rust function is done.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-ownership-and-borrowing"><a class="header" href="#handling-ownership-and-borrowing">Handling Ownership and Borrowing</a></h1>
<h2 id="identifying-ownership-and-borrowing-in-rust"><a class="header" href="#identifying-ownership-and-borrowing-in-rust">Identifying Ownership and Borrowing in Rust</a></h2>
<p>Rust enforces strict <a href="ownership.html">ownership</a> rules. When a function in Rust <strong>takes ownership</strong> of a value (e.g., <code>Box</code>, <code>Vec</code>), it means the caller no longer owns that value and cannot use it again unless ownership is returned. <a href="borrowing_and_aliasing.html">Borrowing</a> (<code>&amp;T</code> or <code>&amp;mut</code> T) allows temporary access to a value without transferring ownership.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn take_ownership(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // Takes ownership of v
    v
}

fn borrow(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // Borrows v temporarily
    v[0]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-ownership-in-java"><a class="header" href="#handling-ownership-in-java">Handling Ownership in Java</a></h2>
<p>When Rust functions take ownership of values, Java needs to manage when to free the underlying memory. This typically involves:</p>
<ol>
<li><strong>Taking ownership</strong>: If Java creates the object (e.g., calling <code>Box</code> in Rust), it must free the object explicitly.</li>
<li><strong>Borrowing</strong>: Java must ensure the memory is valid during the borrowed reference’s lifetime.</li>
</ol>
<h3 id="what-you-need-to-do-1"><a class="header" href="#what-you-need-to-do-1">What You Need to Do:</a></h3>
<ul>
<li><strong>For functions that take ownership</strong>: You need to call the appropriate Rust cleanup function (<code>like</code> drop or <code>free</code>) using <strong>MethodHandle</strong> in Java.</li>
<li><strong>For borrowed references</strong>: Manage memory using <strong>Arenas</strong> to ensure that memory remains valid for the borrowed duration.</li>
</ul>
<h3 id="java-example-handling-ownership"><a class="header" href="#java-example-handling-ownership">Java Example (Handling Ownership):</a></h3>
<pre><code class="language-java">// Create a Rust-owned Box and pass ownership MemorySegment rustBox = (MemorySegment) 
RustBindings.createBox.invokeExact(10); 

// Call Rust function to take ownership of the box 
RustBindings.takeOwnership.invokeExact(rustBox); 

// Manually free the Box when done 
RustBindings.freeBox.invokeExact(rustBox); // Ensures no memory leaks
</code></pre>
<h3 id="explanation-4"><a class="header" href="#explanation-4">Explanation:</a></h3>
<p><strong>MemorySegment</strong> represents the Rust-allocated memory in Java. After transferring ownership to Rust, Java explicitly calls <code>freeBox</code> to release the memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-layouts-and-structs"><a class="header" href="#memory-layouts-and-structs">Memory Layouts and Structs</a></h1>
<h2 id="identifying-structs-and-memory-layouts-in-rust"><a class="header" href="#identifying-structs-and-memory-layouts-in-rust">Identifying Structs and Memory Layouts in Rust</a></h2>
<p>When Rust returns complex data types like <strong>structs</strong> or <strong>arrays</strong>, Java needs to correctly interpret their memory layout. Rust’s struct fields are aligned in memory based on their type sizes, so Java must use <strong>StructLayout</strong> and <a href="value_layout.html">ValueLayout</a> to match the Rust memory layout exactly.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[repr(C)]</code> attribute ensures that the memory layout of <code>Point</code> follows the <code>C ABI</code>, making it compatible with Java’s Foreign Function and Memory API.</p>
<h2 id="handling-structs-in-java"><a class="header" href="#handling-structs-in-java">Handling Structs in Java</a></h2>
<p>Java uses <strong>StructLayout</strong> to define memory layouts that match Rust’s struct layouts. When dealing with Rust structs, it’s essential to ensure that the memory allocated on the Java side is properly aligned and of the correct size to match the layout of the Rust struct.</p>
<h3 id="what-you-need-to-do-2"><a class="header" href="#what-you-need-to-do-2">What You Need to Do:</a></h3>
<ul>
<li>Use <strong>StructLayout</strong> to define the memory layout that mirrors the fields of the Rust struct.</li>
<li>Allocate a <strong>MemorySegment</strong> that is large enough and properly aligned to hold the struct’s data.</li>
</ul>
<h2 id="java-example-handling-structs"><a class="header" href="#java-example-handling-structs">Java Example (Handling Structs):</a></h2>
<pre><code class="language-java">// Define the memory layout of the Rust `Point` struct in Java
StructLayout pointLayout = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName("x"),  // Field `x` (i32 in Rust)
    ValueLayout.JAVA_INT.withName("y")   // Field `y` (i32 in Rust)
);

// Allocate memory for the struct
var arena = Arena.ofConfined();  // Confined Arena for memory management
MemorySegment pointSegment = arena.allocate(pointLayout);

// Set the fields of the Point struct
VarHandle xHandle = pointLayout.varHandle(PathElement.groupElement("x"));
VarHandle yHandle = pointLayout.varHandle(PathElement.groupElement("y"));
xHandle.set(pointSegment, 0, 10);  // Set x to 10
yHandle.set(pointSegment, 0, 20);  // Set y to 20
</code></pre>
<h2 id="explanation-5"><a class="header" href="#explanation-5">Explanation:</a></h2>
<p><strong>StructLayout</strong>: Defines the layout of the Rust <code>Point</code> struct, where each field is aligned according to its type (in this case, both fields are <code>i32</code>, so each is 4 bytes).
<strong>VarHandle</strong>: Used to access and set individual fields (<code>x</code> and <code>y</code>) in the memory segment allocated for the struct.
<strong>MemorySegment</strong>: Represents the allocated memory for the struct, and Java can safely manipulate it according to the struct’s layout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-thread-safety-in-rust"><a class="header" href="#handling-thread-safety-in-rust">Handling Thread Safety in Rust</a></h1>
<h2 id="identifying-thread-safety-in-rust"><a class="header" href="#identifying-thread-safety-in-rust">Identifying Thread Safety in Rust</a></h2>
<p>In Rust, <strong>thread safety</strong> is ensured using the <a href="send_and_sync.html">Send and Sync</a> traits. If a Rust function operates across multiple threads, the types used in the function must implement <code>Send</code> or <code>Sync</code>. For example, if a Rust function uses a <strong>Mutex</strong> or <strong>Arc</strong> to manage shared data, it is thread-safe.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

pub fn create_shared_data() -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; {
    Arc::new(Mutex::new(42))
}
<span class="boring">}</span></code></pre></pre>
<p>The function returns a thread-safe <code>Arc&lt;Mutex&lt;i32&gt;&gt;</code>, which ensures that multiple threads can safely access and modify the shared data.</p>
<h2 id="ensuring-thread-safety-in-java"><a class="header" href="#ensuring-thread-safety-in-java">Ensuring Thread Safety in Java</a></h2>
<p>When dealing with thread safety across languages, Java must ensure that memory is safely shared between threads. Java’s Foreign Function and Memory API provides <strong>Shared Arenas</strong>, which allow memory to be safely accessed by multiple threads.</p>
<h3 id="what-you-need-to-do-3"><a class="header" href="#what-you-need-to-do-3">What You Need to Do:</a></h3>
<ul>
<li>Use <strong>Shared Arenas</strong> when you expect shared memory or thread-safe operations in Rust.</li>
<li>Java also provides synchronization mechanisms like <strong>synchronized blocks</strong> to ensure thread safety.</li>
</ul>
<h3 id="java-example-handling-thread-safety"><a class="header" href="#java-example-handling-thread-safety">Java Example (Handling Thread Safety):</a></h3>
<pre><code class="language-java">// Create a shared arena for multi-threaded operations
var sharedArena = Arena.ofShared();
MemorySegment sharedSegment = sharedArena.allocate(8);  // Allocate space for shared memory

// Call Rust function that operates on shared data
RustBindings.createSharedData.invokeExact(sharedSegment);

// Access shared data across threads (ensure proper synchronization in Java)
synchronized (sharedSegment) {
    // Safe access to shared memory here
}
</code></pre>
<h3 id="explanation-6"><a class="header" href="#explanation-6">Explanation:</a></h3>
<ul>
<li><strong>Shared Arena</strong>: Ensures that memory is safely shared across threads in Java when interacting with Rust’s thread-safe types like <code>Arc</code> and <code>Mutex</code>.</li>
<li><strong>Synchronized Block</strong>: Ensures that only one thread accesses the shared memory at a time, mimicking Rust’s ownership rules for shared data.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-rusts-enums-and-option-types"><a class="header" href="#handling-rusts-enums-and-option-types">Handling Rust’s Enums and Option Types</a></h1>
<h2 id="identifying-enums-in-rust"><a class="header" href="#identifying-enums-in-rust">Identifying Enums in Rust</a></h2>
<p>Rust enums can either be <strong>C-like (simple variants)</strong> or contain <strong>data</strong>. When using Rust enums with Java, the structure of the enum must be carefully mapped to Java’s memory layout and control structures.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>This is a typical enum used for error handling in Rust. The <code>Result</code> enum can hold either an <code>Ok</code> variant (with data) or an <code>Err</code> variant (with error information).</p>
<h2 id="handling-enums-in-java"><a class="header" href="#handling-enums-in-java">Handling Enums in Java</a></h2>
<p>Java doesn’t natively support Rust enums, but you can handle them by:</p>
<ol>
<li>Mapping the enum’s layout to Java using <strong>MemoryLayout</strong>.</li>
<li><strong>Using tagged unions</strong>: Accessing the enum’s <strong>tag</strong> (discriminator) to determine which variant is active.
What You Need to Do:</li>
</ol>
<ul>
<li>Use <strong>MemoryLayout.structLayout()</strong> to match the enum layout.</li>
<li>Use <strong>VarHandle</strong> to check the enum’s tag and access the relevant data based on the active variant.</li>
</ul>
<h3 id="java-example-handling-enums"><a class="header" href="#java-example-handling-enums">Java Example (Handling Enums):</a></h3>
<pre><code class="language-java">// Define the memory layout for the Rust `Result` enum (assumes a tag and data layout)
StructLayout resultLayout = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName("tag"),  // Enum tag (discriminator)
    ValueLayout.JAVA_INT.withName("data")  // Enum data (e.g., Ok or Err)
);

// Allocate memory for the enum
MemorySegment resultSegment = arena.allocate(resultLayout);

// Access the enum tag to determine the variant
VarHandle tagHandle = resultLayout.varHandle(PathElement.groupElement("tag"));
int tag = (int) tagHandle.get(resultSegment);

// Check the enum variant (assumes 0 for Ok, 1 for Err)
if (tag == 0) {
    // Handle Ok variant
} else {
    // Handle Err variant
}
</code></pre>
<h3 id="explanation-7"><a class="header" href="#explanation-7">Explanation:</a></h3>
<p><strong>StructLayout</strong>: Defines the layout of the <code>Result</code> enum, where the tag field identifies the active variant (similar to a union tag in C).
<strong>VarHandle</strong>: Used to read the tag and access the data based on the active enum variant.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-common-data-structures"><a class="header" href="#handling-common-data-structures">Handling Common Data Structures</a></h1>
<p>text</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edge-cases-and-troubleshooting"><a class="header" href="#edge-cases-and-troubleshooting">Edge Cases and Troubleshooting</a></h1>
<p>text</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comprehensive-example"><a class="header" href="#comprehensive-example">Comprehensive Example</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-layout"><a class="header" href="#value-layout">Value Layout</a></h1>
<p>ValueLayout is the most primitive layout type, representing the layout of,
well, primitives. They are:
<br></p>
<ol>
<li>ValueLayout.ADDRESS</li>
<li>ValueLayout.JAVA_BOOLEAN</li>
<li>ValueLayout.JAVA_BYTE</li>
<li>ValueLayout.JAVA_CHAR</li>
<li>ValueLayout.JAVA_DOUBLE</li>
<li>ValueLayout.JAVA_FLOAT</li>
<li>ValueLayout.JAVA_INT</li>
<li>ValueLayout.JAVA_LONG</li>
<li>ValueLayout.JAVA_SHORT</li>
<li>ValueLayout.ADDRESS_UNALIGNED</li>
<li>ValueLayout.JAVA_CHAR_UNALIGNED</li>
<li>ValueLayout.JAVA_DOUBLE_UNALIGNED</li>
<li>ValueLayout.JAVA_FLOAT_UNALIGNED</li>
<li>ValueLayout.JAVA_INT_UNALIGNED</li>
<li>ValueLayout.JAVA_LONG_UNALIGNED</li>
<li>ValueLayout.JAVA_SHORT_UNALIGNED</li>
</ol>
<p>These all correspond to the Java
primitives (ADDRESS is a bit special), aligned and unaligned, which have
direct mappings to C primitive types.<br />
<br></p>
<div class="table-wrapper"><table><thead><tr><th><strong>Java Type</strong></th><th><strong>C Type</strong></th></tr></thead><tbody>
<tr><td>ValueLayout.ADDRESS</td><td>pointer</td></tr>
<tr><td>ValueLayout.ADDRESS_UNALIGNED</td><td>pointer with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_BOOLEAN</td><td>char but must be 0 or 1</td></tr>
<tr><td>ValueLayout.JAVA_BYTE</td><td>char</td></tr>
<tr><td>ValueLayout.JAVA_CHAR</td><td>short storing a UTF-16 codepoint</td></tr>
<tr><td>ValueLayout.JAVA_CHAR_UNALIGNED</td><td>ditto with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_DOUBLE</td><td>double</td></tr>
<tr><td>ValueLayout.JAVA_DOUBLE_UNALIGNED</td><td>double with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_FLOAT</td><td>float</td></tr>
<tr><td>ValueLayout.JAVA_FLOAT_UNALIGNED</td><td>float with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_INT</td><td>int</td></tr>
<tr><td>ValueLayout.JAVA_INT_UNALIGNED</td><td>int with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_LONG</td><td>long</td></tr>
<tr><td>ValueLayout.JAVA_LONG_UNALIGNED</td><td>long with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_SHORT</td><td>short</td></tr>
<tr><td>ValueLayout.JAVA_SHORT_UNALIGNED</td><td>short with alignment 1</td></tr>
</tbody></table>
</div><br>  
<p>So the _UNALIGNED versions are exactly the same as their counterparts
except that they have an alignment of 1. This allows storing them unaligned,
but it will also force the JVM to issue special instruction sequences to load
values, since most CPU architectures do not natively support unaligned loads
and stores from or to memory. It is also worth noting that
ValueLayout.JAVA_DOUBLE and ValueLayout.JAVA_LONG have
platform-dependent alignment because some CPU architectures require
natural alignment (size = alignment, so 8 in this case) whereas some like
x86 only require an alignment of 4. All other primitives are defined to have
natural alignment.</p>
<p>Beyond representing primitive types, ValueLayouts also provide access to
different byte ordering (also known as endianness) through the
.withOrder(ByteOrder) method. The choices for ByteOrder are BIG_ENDIAN,
and LITTLE_ENDIAN, although the static method ByteOrder.nativeOrder()
will return whichever of those your CPU natively uses (usually
LITTLE_ENDIAN). This is required by many serialization formats, such as
most network formats, because many of them require BIG_ENDIAN byte
order while most CPU architectures only natively support LITTLE_ENDIAN.
Rust doesn’t have int, long, etc., so we must use a different translation to
Rust types:</p>
<br>  
<div class="table-wrapper"><table><thead><tr><th><strong>Java Type</strong></th><th><strong>Rust Type</strong></th></tr></thead><tbody>
<tr><td>ValueLayout.ADDRESS</td><td>pointer or Option&lt;reference&gt;</td></tr>
<tr><td>ValueLayout.ADDRESS_UNALIGNED</td><td>ditto with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_BOOLEAN</td><td>bool</td></tr>
<tr><td>ValueLayout.JAVA_BYTE</td><td>i8</td></tr>
<tr><td>ValueLayout.JAVA_CHAR</td><td>u16 storing a UTF-16 codepoint</td></tr>
<tr><td>ValueLayout.JAVA_CHAR_UNALIGNED</td><td>ditto with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_DOUBLE</td><td>f64</td></tr>
<tr><td>ValueLayout.JAVA_DOUBLE_UNALIGNED</td><td>f64 with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_FLOAT</td><td>f32</td></tr>
<tr><td>ValueLayout.JAVA_FLOAT_UNALIGNED</td><td>f32 with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_INT</td><td>i32</td></tr>
<tr><td>ValueLayout.JAVA_INT_UNALIGNED</td><td>i32 with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_LONG</td><td>i64</td></tr>
<tr><td>ValueLayout.JAVA_LONG_UNALIGNED</td><td>i64 with alignment 1</td></tr>
<tr><td>ValueLayout.JAVA_SHORT</td><td>i16</td></tr>
<tr><td>ValueLayout.JAVA_SHORT_UNALIGNED</td><td>i16 with alignment 1</td></tr>
</tbody></table>
</div><br>  
<p>For additional information on value layouts, visit Oracle's <a href="https://cr.openjdk.org/~mcimadamore/jdk/FFM_22_PR/javadoc/java.base/java/lang/foreign/ValueLayout.html">official documentation</a>, and official Rust resource <a href="https://doc.rust-lang.org/nomicon/"><em>The Rustonomicon</em></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-object-and-dynamic-library-files"><a class="header" href="#shared-object-and-dynamic-library-files">Shared Object and Dynamic Library Files</a></h1>
<p>Shared object and dynamic library files effectively serve the same purpose in this
scope. They provide executable code to outside sources. This means that once Java is
given the address to the code for a function in this file, it is ready to run once
called. Although they effectively share the same purpose, their file types differ
based on the system running. Below is a table with each file extension used by three
of the most common operating systems.</p>
<br>  
<div class="table-wrapper"><table><thead><tr><th><strong>System</strong></th><th><strong>File Extension</strong></th></tr></thead><tbody>
<tr><td>Linux</td><td>.so</td></tr>
<tr><td>Windows</td><td>.dll</td></tr>
<tr><td>Mac</td><td>.dylib</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="arenas"><a class="header" href="#arenas">Arenas</a></h1>
<p>Arenas are a way that Java provides developers to allocate memory in a way
that is particularly useful for creating bindings. Arenas are like a
stack of memory, and its space can be split in various ways, and its lifetime
can be set by various types. The main idea of where arenas can be used is
that they can create space to store objects in Java called Memory
Segments. These memory segments can store data such as
variables, data structures, and functions in a space that the garbage
collector treats differently. That means information stored in
these arenas can be passed to and from foreign functions without worrying about
whether Java’s garbage collector has tampered with the space.</p>
<p>There are four different types of arenas: confined, automatic, shared,
and custom. Confined arenas and shared arenas are very similar. They both will live as
long as the Java program unless they are manually closed by the user using
the <code>.close()</code> method on the arena object. The key difference between the
two is that confined arenas can only be accessed by a single thread, while
shared arenas can be accessed by multiple threads. This causes a weird
interaction with shared arenas. When a confined arena is closed, its memory
is immediately freed and that’s all there is to it. When a shared arena is
closed, it invalidates all Java references to the space in memory, but it does
not immediately free it as the process takes longer, meaning that the space
in memory is technically alive for a very short amount of time after the
arena is closed. These arenas are useful for creating Rust bindings because they can
guarantee a space in memory cannot be accessed once closed, so they can be
implemented into functions to guarantee proper memory safety practices.</p>
<p>The API descriptions for automatic arenas typically vaguely describe their closing
behavior, such as “the garbage collector eventually frees it automatically”.
To better describe its behavior, The garbage collector will only free the automatic
arena either at the end of the Java program or when it determines that the
arena is unreachable. But what does the garbage collector see as unreachable?</p>
<p>Testing will show that Java will not close the arena even if every
memory segment inside is set to null. The information inside the arena
has no bearing on the garbage collector’s decision to keep it around. However, a way
to guarantee that the garbage collector determines the arena as unreachable is to set
the arena to null. This means that automatic arenas can be useful and reliable for
creating bindings as well, especially if it is not clear when a certain arena should
be closed. The only downside of the automatic arena is its interaction with the
garbage collector. It is possible this could cause some sort of increased overhead.</p>
<p>With an Arena, you can call <code>arena.allocate(size, alignment)</code> to allocate
memory within the arena. Allocations cannot be individually freed with
Arenas, it’s either all or nothing. Global Arenas
are useful for set-and-forget things, like for loading the Rust library, since this
does not need to be freed. Confined Arenas are good for data that cannot be
safely shared across threads, so for types that don’t implement the Send
trait. Auto Arenas are nice if it is difficult to figure out
when something should be deallocated. Although this isn’t very common as <code>drop()</code>
should be called on Rust objects that require cleanup, and Java’s
garbage collector will not take care of this.</p>
<p>For more information on arenas, visit Oracle's <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html">official documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>A piece of data must be owned by at most one variable at any given time,
even across an FFI boundary. If Rust has ownership of a <code>Vec&lt;T&gt;</code> for
instance, Java cannot decide to take control of it, as, in this case, that would
lead to both Java and Rust calling drop when done with the type, causing a
double free of the backing array. And that’s one of the better outcomes, as
generally types do not expect to suddenly be in an invalid state due to
external mucking, nor is there much they can do about it. One exception to
this rule are types that implement Copy, as they can be blindly memcopied
to create an identical clone of the original (barring any atomicity issues if
this is done across threads), though most types do not implement Copy so
this isn’t very useful when creating these bindings.</p>
<h2 id="example-of-ownership"><a class="header" href="#example-of-ownership">Example of Ownership</a></h2>
<p>In this calculator code, ownership is demonstrated in how PostfixCalculator
manages its stack:</p>
<pre><code class="language-rust ignore">struct PostfixCalculator {
    stack: VecDeque&lt;f64&gt;,
}

impl PostfixCalculator {
    fn new() -&gt; Self {
        PostfixCalculator {
            stack: VecDeque::new(),
        }
    }
}</code></pre>
<p>PostfixCalculator owns its stack. When PostfixCalculator is
dropped, so is its stack, which automatically cleans up without the
programmer needing to manually manage memory.</p>
<p>To learn more about ownership, it is recommended to read these official Rust
resources: <em>The Rust Programming Language</em> chapter
<a href="https://rust-book.cs.brown.edu/ch04-00-understanding-ownership.html">4</a>, and <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/obrm.html">6</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing-and-aliasing"><a class="header" href="#borrowing-and-aliasing">Borrowing and Aliasing</a></h1>
<p>Data can be “borrowed” as references, either immutably <code>&amp;T</code> or mutably
<code>&amp;mut T</code>. The compiler enforces a sort of reader-writer lock on the type: it
can have either multiple readers (immutable/shared references, <code>&amp;T</code>) or a
singular writer (mutable/exclusive reference, <code>&amp;mut T</code>). The compiler will
assume that the data behind a shared reference will not mutate (unless the
type opts out of it with <code>UnsafeCell</code>, which can be used for custom special
types, which should not be used to enforce users’ types) and the compiler
will assume that no other code or data can reference, read, or mutate the
data behind an exclusive reference (there is no opt out, this must never
happen!). The fact that Rust can make these assumptions is what makes it
so fast and efficient, but it also means you are restricted from coding practices
that break them.</p>
<p>This is approximately the exact opposite of Java’s memory model, where
everything is a mutable reference to the underlying object. While Java can’t
arbitrarily clone objects, meaning it can’t make copies of a class holding an
exclusive reference, it can make those objects live arbitrarily long. This
means it is essential to either detect that the reference is still live and refuse to
service any other borrows, or invalidate the reference in order to service
other borrows. There is a Rust type that effectively performs this latter
approach: <code>RefCell&lt;T&gt;</code>.</p>
<p>Raw pointers in Rust do not have such aliasing restrictions with regard to
each other, so we are free to have any number of constant <code>*const T</code> and
mutable <code>*mut T</code> pointers coexisting. Raw pointer semantics are just like
they are in C, and are in fact even more lenient than C pointers since C
pointers of differing types are not allowed to alias. You’re still not allowed to
mess with ownership – the owner of the type still acts like your pointers
don’t exist and so still assumes it is the arbiter of reads and writes – but if
you have ownership of the type you can just make sure to only interact with
it using raw pointers. This is exactly what <code>UnsafeCell&lt;T&gt;</code> and <code>Cell&lt;T&gt;</code> do to
enable shared mutability, and those are the primitives fancy types like
<code>Rc&lt;T&gt;</code> use to allow shared ownership.</p>
<h2 id="example-of-borrowing-and-aliasing"><a class="header" href="#example-of-borrowing-and-aliasing">Example of Borrowing and Aliasing</a></h2>
<p>In this calculator code, Borrowing and Aliasing is demonstrated.</p>
<pre><code class="language-rust ignore">struct PostfixCalculator {
    stack: VecDeque&lt;f64&gt;,
}

impl PostfixCalculator {
    fn new() -&gt; Self {
        PostfixCalculator {
            stack: VecDeque::new(),
        }
    }
}</code></pre>
<p>Rust's borrowing rules ensure that references to
data (borrowing) do not outlive the data they reference (ownership).
This prevents dangling pointers</p>
<p>To learn more about borrowing and aliasing, it is recommended to read these official Rust
resources: <em>The Rust Programming Language</em> chapter
<a href="https://rust-book.cs.brown.edu/ch04-02-references-and-borrowing.html">4.2</a>, and <em>The Rustonomicon</em> chapters <a href="https://doc.rust-lang.org/nomicon/">3.1 and 3.2</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>Rust constantly wants to know "what exactly is that reference referencing?". Most
things don’t live
forever, so Rust also checks that developers don’t try to use it or reference it
after it has been moved. A move is a change in ownership which potentially means
physically moving it in memory and invalidating any pointers to it. <code>drop()</code>,
for instance, takes ownership of an object so it can kill it. Anyone familiar
with pointers in C has a decent understanding of the concept of
pointer lifetimes: do not use the pointer after the object has been deleted or
moved. As long as a shared reference exists, no mutable references may exist
and the object must not be moved; and as long as a mutable reference
exists, no other references may exist and the object must not be moved.
The compiler enforces a more stringent test on safe code, that breaking
those rules must provably never happen, leading to some cases where you
know it will not happen, yet the compiler can not prove it, so it does not allow
it. Luckily we do not need to follow the compiler’s test, we only need to follow
those simple rules.</p>
<p>Unfortunately, for arbitrary code the lifetimes involved can get quite
intricate. <code>fn foo&lt;’a&gt;(input: &amp;’a) -&gt; TypeWithLifetime&lt;’a&gt;</code> creates a
transitive relationship between the lifetime of input and
<code>TypeWithLifetime&lt;’a&gt;</code>. While we may be able to enforce a simple one-to-one
lifetime relationship, it’s unclear if we can feasibly enforce that A lives as
long as B lives as long as C lives as long as D lives as long as… Certainly, if it
requires invasive changes to types crossing the FFI boundary, such as every
reference in every struct needing to be converted to a <code>RefCell&lt;&amp;T&gt;</code>, that
would be very inconvenient for users.</p>
<h2 id="example-of-lifetimes"><a class="header" href="#example-of-lifetimes">Example of Lifetimes</a></h2>
<p>The code does not explicitly use annotated lifetimes because it does not
require them due to its simplicity. However, the concept is there implicitly:</p>
<pre><code class="language-rust ignore">struct PostfixCalculator {
    stack: VecDeque&lt;f64&gt;,
}

impl PostfixCalculator {
    fn new() -&gt; Self {
        PostfixCalculator {
            stack: VecDeque::new(),
        }
    }
}

fn evaluate(&amp;mut self, tokens: Vec&lt;&amp;str&gt;) -&gt; Result&lt;f64, String&gt;
{
    // use of `self` which has an implicit lifetime
}</code></pre>
<p>This example implicitly uses lifetimes to ensure that references within the
evaluate function do not outlive the PostfixCalculator instance they
reference. Rust's lifetime elision rules automatically handle this in most
cases, but explicit lifetime annotations can be used for more complex
scenarios.</p>
<p>To learn more about lifetimes, it is recommended to read these official Rust
resources: <em>The Rust Programming Language</em> chapter
<a href="https://rust-book.cs.brown.edu/ch10-03-lifetime-syntax.html">10.3</a>, and <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/lifetimes.html">3.3</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subtyping-and-variance"><a class="header" href="#subtyping-and-variance">Subtyping and Variance</a></h1>
<p>As a warning, this section will be complex and type-theory heavy, but the gist for
this scope
is that there
are three types of lifetime relationships:</p>
<ul>
<li>
<p>Covariant: ‘a can be used where a ‘b is expected if ‘a is as long or
longer than ‘b. Shared references are covariant because a longer-living reference than required can always be given. Tree structures
where you can only delete leaves kind of act like this (so a
<code>RefCell&lt;&amp;T&gt;</code> chain of references follows this).</p>
</li>
<li>
<p>Contravariant: ‘a can be used where a ‘b is expected if ‘a lives as long
or shorter than ‘b. This only applies to arguments inside of functions or
closures, so those should be banned from use to avoid any headaches. Closures
aren’t application binary interface safe so they are already banned,
and functions as arguments can be replaced with Java upcalls where
less care is needed.</p>
</li>
<li>
<p>Invariant: ‘a cannot be used, the thing you pass in must live exactly as
long as ‘b. This applies to exclusive references, because Rust allows
you to modify data behind an exclusive reference and potentially
change its lifetime, and the caller would have no idea its lifetime got changed, so
that would fail once the caller tries to use it within
its old lifetime, but outside its new lifetime. If an exclusive reference is
checked for validity first before every time it is used, this can work (it’s
effectively <code>RefCell&lt;&amp;mut T&gt;</code>), but that then still bans every function
that touches an exclusive reference directly. Honestly, this may not be truly
solvable, it might just have to be invasive to the
programmer.</p>
</li>
</ul>
<p>To learn more about subtyping and variance, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/subtyping.html">3.8</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unwinding"><a class="header" href="#unwinding">Unwinding</a></h1>
<p>With the default panic handler (fittingly named “unwind”), when Rust code
calls <code>panic!()</code> Rust will begin walking local variables in the call stack to drop
them, then kill the thread. If the type is mutably shared across threads,
such as with a <code>Mutex&lt;T&gt;</code> does, then it may be in an inconsistent state,
though it should not be necessary to have a custom type doing that. However, What
is a concern is Rust calling drop on some types while they’re potentially in
inconsistent states. For example, say a <code>JavaRef&lt;T&gt;</code> type is used to represent a
reference held by Java. If it is busy updating its pointer for instance, and it
panics in that function, Rust’s unwinding will eventually call <code>drop()</code> on it, so
now the drop code is working with a <code>JavaRef&lt;T&gt;</code> with an invalid pointer.
Rust does have another panic handler called “abort” which just prints a stack
trace and aborts the process, which might be a better option if the types being used
are not believed to be unwind-safe.</p>
<h2 id="example-of-unwinding"><a class="header" href="#example-of-unwinding">Example of Unwinding</a></h2>
<p>Unwinding is implicit in Rust's error handling if a panic occurs. For explicit
handling:</p>
<pre><code class="language-rust ignore">match calculator.evaluate(tokens) {
    Ok(result) =&gt; println!("Result: {}", result),
    Err(e) =&gt; println!("Error: {}", e),
}</code></pre>
<p>To learn more about unwinding, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/unwinding.html">7</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phantom-data"><a class="header" href="#phantom-data">Phantom Data</a></h1>
<p>Sometimes, when working with unsafe code, there may be a situation where
lifetimes are associated with a struct, but not part of a field. For example:</p>
<pre><code class="language-rust ignore">struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
}</code></pre>
<p>‘a isn’t being used in the body of this struct, so it’s unbounded. In Rust,
making these types of lifetime annotations for structs is not allowed because
of the implications it would have with maintaining correct variance and drop
checking. The solution Rust offers is <code>PhantomData</code>, which is a special marker
type. It doesn’t take up more memory, but it simulates a field of the desired struct
type to implement for static analysis. It is easy to implement, the
resulting struct would be:</p>
<pre><code class="language-rust ignore">struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,
}</code></pre>
<p>This way, the lifetime will be bounded to a “field” of the struct <code>Iter</code>. This may
bring up complications when writing a tool that automatically generates
bindings to call code because of the way it is designed. As previously
explained, method handles must be written for the different types a
function may be working with, and the <a href="https://openjdk.org/jeps/454">Foreign Function and Memory API</a>
may be incompatible or unable to accommodate for a case where
<code>PhantomData</code> is used.
Rust uses <a href="unwinding.html">unwinding</a> to handle panics (unexpected errors) by default.
In this code, any panic (e.g., an out-of-bounds error) would unwind the stack
safely, cleaning up as it goes. Rust allows opting out of unwinding with
<code>panic=abort</code> for faster binaries.</p>
<p>To learn more about phantom data, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/phantom-data.html">3.10</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync"><a class="header" href="#send-and-sync">Send and Sync</a></h1>
<ul>
<li>Send: the type can be moved between threads.</li>
<li>Sync: a type can be shared between threads (logically equivalent to <code>&amp;T</code>
being Send)</li>
</ul>
<p>By default, most types are Send and Sync. If a type is moved to another
thread, it is fine because it owns its data and therefore nothing else can
touch that data or cause thread safety issues. If a shared reference is moved to
another thread, that is fine because the mere existence of a
shared reference means the data can no longer mutate, so there’s nothing
needing synchronization between threads. If an exclusive reference is moved, again
it is fine because that exclusive reference is the only thing
allowed to look at or modify the underlying data, so there is no need to
synchronize anything. The only types that are not both Send and Sync are
types that cheat the aliasing and ownership rules like <code>UnsafeCell&lt;T&gt;</code> and
<code>Rc&lt;T&gt;</code>.</p>
<p>Luckily, Java actually allows for this to be enforced. <code>Arena.ofConfined()</code> gives us
a thread-local memory <a href="arenas.html">arena</a>, and if code tries to use a <code>MemorySegment</code>
allocated from this arena in another thread it will throw an exception. This is
an absolute life saver, as it allows for the use of <code>RefCell&lt;T&gt;</code>, which is neither
Send nor Sync, and which is useful for fixing many of the incongruities
between Java and Rust’s memory models.</p>
<h2 id="example-of-thread-safety-and-send-and-sync"><a class="header" href="#example-of-thread-safety-and-send-and-sync">Example of Thread Safety and Send and Sync</a></h2>
<pre><code class="language-rust ignore">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let calculator = Arc::new(Mutex::new(PostfixCalculator::new()));
    let calculator_clone = Arc::clone(&amp;calculator);
    let handle = thread::spawn(move || {
        let mut calc = calculator_clone.lock().unwrap();
        let tokens: Vec&lt;&amp;str&gt; = "3 4 +".split_whitespace().collect();
        calc.evaluate(tokens)
    });
    
    match handle.join().unwrap() {
        Ok(result) =&gt; println!("Result from thread: {}", result),
        Err(e) =&gt; println!("Error from thread: {}", e),
    }
}</code></pre>
<p>Thread Safety: The Arc and Mutex wrapping of <code>PostfixCalculator</code> ensures that
it can be safely shared and mutated across threads. Arc allows for shared
ownership across threads, while Mutex provides mutual exclusion,
preventing <a href="data_races.html">data races</a>.</p>
<p>To learn more about Send and Sync traits, it is recommended to read these official Rust
resources: <em>The Rust Programming Language</em> chapter
<a href="https://rust-book.cs.brown.edu/ch16-04-extensible-concurrency-sync-and-send.html">16.4</a>, and <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">8.2</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-races"><a class="header" href="#data-races">Data Races</a></h1>
<p>Data races occur when multiple threads try to access the same memory
segment, trying to write to it, and they can cause undefined behavior. Safe
Rust guarantees that no data races will occur, and a big player for this is the
<a href="ownership.html">ownership</a> model. By definition, if a value can only have one owner
(can make changes), then it can only be written to by its single owner. However,
general race conditions are not prevented in Rust. They simply can’t be
prevented from a mathematical standpoint, due to the way the scheduler
works in different operating systems. This is something that is out of the
developer's'
control. This means that while a program may get deadlocked, or have
incorrect synchronization, a Rust program will still be safe.</p>
<p>To learn more about subtyping and variance, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/races.html">8.1</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomics"><a class="header" href="#atomics">Atomics</a></h1>
<p>Atomics are types that support operations in a thread-safe manner without
external synchronization. For example, consider wanting to use a counter,
<code>foo</code>, you want to use across different threads. It would not be safe to
increment the counter using <code>foo++</code>, because that could result in a race
condition: different threads trying to increment <code>foo</code> by one will cause
undefined behavior. Locking can be used to make sure one thread
increments the value of <code>foo</code> by one, and then the other one, but it has
severe performance costs. Let’s say at first, <code>foo = 0</code>. Then, after both
threads write to it, <code>foo = 2</code> should be true. The way atomics would handle
this is: both threads would check if the value of <code>foo</code> is 0, and if it is,
increment to 1, otherwise, reevaluate. This would ensure that, no matter the
order the operating system decides to call these operations, at the end, <code>foo</code>
will be 2. Rust makes it very easy to work with atomics, for <code>foo</code>, just
write:</p>
<p><code>let foo = Arc::new(AtomicUsize::new(0));</code></p>
<p>To learn more about atomics, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/atomics.html">8.3</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-and-hardware-reordering"><a class="header" href="#compiler-and-hardware-reordering">Compiler and Hardware Reordering</a></h1>
<h2 id="compiler-reordering"><a class="header" href="#compiler-reordering">Compiler Reordering</a></h2>
<p>Rust’s compiler makes many optimizations to reduce the number of
operations the CPU will actually have to process. Sometimes it may as well
just remove operations. For example:</p>
<pre><code class="language-rust ignore">let x: i32 = 1;
x = 2;
x = 3;</code></pre>
<p>The compiler would remove the second line, <code>x = 2</code>, because it does not
change the result. The code will still define <code>x</code>, initialize it as an i32 variable
with value 1, and end with x having the value 3. However, if the result is not
used, the compiler is likely to completely remove all mentions of x. Why
bother generating code and allocating stack space for a value nobody will
notice is missing?</p>
<p>Rust uses the LLVM compiler infrastructure as its backend, the same thing
that the clang C compiler and clang++ C++ compiler use to generate
machine code. LLVM is very smart, and will do things such as delete dead
code, reorder operations to better saturate out-of-order CPUs, merge
redundant operations (<code>x += 1; x += 1</code> will be transformed to <code>x += 2</code>), keep
things in registers rather than ever touching memory, turn loops of normal
arithmetic into loops using SIMD/vector instructions. The point is, it is not clear
what the code is actually going to look like. The only thing that is guranteed is
that the compiler isn’t allowed to reorder things like print statements around each
other, or move <code>x += 1</code> to after a function call that uses <code>x</code>.</p>
<p>However, if there is access to another thread, these changes can be observed (with raw
pointers at least, Rust won’t normally let you do this sort of thing without
synchronization for a reason). So when multithreading, the developer must be explicit
to the compiler: “I want all writes performed before this point to be visible
before this operation, so other threads see what I want them to see”. That’s
where <a href="atomics.html">atomics</a> come into play.</p>
<h2 id="hardware-reordering"><a class="header" href="#hardware-reordering">Hardware Reordering</a></h2>
<p>Despite compiler reordering, depending on the hardware
architecture, some operations may be done in a different order by the CPU. This may
be the case due to how memory is accessed internally. Global memory can be
accessible everywhere but is slow, and cache memory is localized and faster.
Programs may have different threads running at the same time. Rust
guarantees that in each thread, the ordering will be correct. Despite that,
having different memory access speeds means that if two threads are
accessing memories that are vastly different in retrieval speed, the order in
which those threads run operations may be in the wrong order relative to
each other. If you now take into consideration that a wrapper
class (like the ones the provided automation tool will generate), ordering might be
thrown off even more. In these cases, Rust and Java’s atomic design
will put more strain on hardware by stalling some threads so that order guarantees
are kept.</p>
<p>To learn more about reordering, it is recommended to read the official Rust
resource <em>The Rustonomicon</em> chapter <a href="https://doc.rust-lang.org/nomicon/atomics.html">8.3</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
